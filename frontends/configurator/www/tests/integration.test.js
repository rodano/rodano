import {DEBUG_CONFIG_URL} from '../app.js';
import {Router} from '../router.js';
import {Configuration} from '../configuration.js';
import {StudyHandler} from '../study_handler.js';
import {EntitiesForms} from '../entities_forms.js';
import {EntitiesPlaceholders} from '../entities_placeholders.js';
import {Entities} from '../model/config/entities.js';

const selected_language = 'en';

export default async function test(bundle, assert, driver) {
	bundle.begin();

	//reset url
	window.location.hash = '';

	//reset clipboard
	navigator.clipboard.writeText('');

	//launch test
	await Configuration.PullFromURL(DEBUG_CONFIG_URL);
	//loading of study is asynchronous
	await driver.wait();

	//load all forms and placeholders to make testing easier
	await EntitiesForms.LoadAll();
	await EntitiesPlaceholders.LoadAll();

	//fold all nodes in the tree
	//reset tree state to have deterministic display style values
	await driver.click('#tree_collapse_all');

	await bundle.describe('reports', async feature => {
		//set click listener to be able to detect downloads
		const download_events = [];
		//detect the download of the file
		function click(event) {
			if(event.target.download) {
				download_events.push(event);
			}
		}
		window.addEventListener('click', click);

		//rules dashboard
		await feature.it('displays rules dashboard', async () => {
			await driver.click('#menubar > li:nth-child(6) > ul > li:nth-child(5) > a');
			await driver.wait();
			assert.open('#rules_dashboard', 'Rules dashboard is displayed');
			assert.equal(await driver.eval('#rules_dashboard_entities > div > h3.dashboard_entity', e => e.textContent), 'Event models', 'First entity in rules dashboard is "Event models"');
			assert.equal(await driver.eval('#rules_dashboard_entities > div > div', e => e.children.length), 1, 'There are 1 event having rules');
			assert.equal(await driver.eval('#rules_dashboard_entities > div > div > div.dashboard_node > h3', e => e.textContent), 'Telephone visit', 'First event having a rule is "Telephone visit"');
			assert.equal(await driver.eval('#rules_dashboard_entities > div > div > div.dashboard_node > h4', e => e.textContent), 'Create rules', 'First kind of rules is "Create rules"');
			assert.equal(await driver.eval('#rules_dashboard_entities > div > div > div.dashboard_node > ul', e => e.children.length), 1, 'There is one creation rule for first event');
		});

		await feature.it('downloads rules dashboard report', async () => {
			await driver.click('#rules_dashboard_report');
			await driver.wait();
			assert.equal(download_events.length, 1, 'Report generated successfully');
			assert.equal(download_events[0].target.download, 'rules.csv', 'Generated report has the good name');
		});

		await feature.it('closes rules dashboard', async () => {
			await driver.click('#rules_dashboard menu > li > a.button');
			await driver.wait();
			assert.closed('#rules_dashboard', 'Rules dashboard is hidden');
		});

		//constraints dashboard
		await feature.it('displays constraints dashboard', async () => {
			await driver.click('#menubar > li:nth-child(6) > ul > li:nth-child(6) > a');
			await driver.wait();
			assert.open('#constraints_dashboard', 'Contraints dashboard is displayed');
			assert.equal(await driver.eval('#constraints_dashboard_entities > div:nth-child(2) > h3.dashboard_entity', e => e.textContent), 'Form models', 'First entity in contraints dashboard is "Form models"');
			assert.equal(await driver.eval('#constraints_dashboard_entities > div:nth-child(2) > div', e => e.children.length), 1, 'There is constraint for first form model');
		});

		await feature.it('downloads constraints dashboard report', async () => {
			await driver.click('#constraints_dashboard_report');
			await driver.wait();
			assert.equal(download_events.length, 2, 'Report generated successfully');
			assert.equal(download_events[1].target.download, 'constraints.csv', 'Generated report has the good name');
		});

		await feature.it('closes constraints dashboard', async () => {
			await driver.click('#constraints_dashboard menu > li > a.button');
			await driver.wait();
			assert.closed('#constraints_dashboard', 'Contraints dashboard is hidden');
		});

		//data validation plan
		await feature.it('generates data validation plan report', async () => {
			await driver.click('#menubar > li:nth-child(6) > ul > li:nth-child(7) > button');
			await driver.wait();
			assert.equal(download_events.length, 3, 'Report generated successfully');
			//the fake click event (generated by csv.js to trigger the download of the file) pops before the event of the click in the menu bar
			//this is because the code that "generates" the download is in the click event listener of the item of the menubar
			assert.equal(download_events[2].target.download, 'dvp.csv', 'Generated report has the good name');
		});

		//remove click listener
		window.removeEventListener('click', click);

		//wait for the browser to finalize the downloads
		//it seems that during a download, it's not possible to interact with the browser
		driver.wait(1000);
	});

	//split tests: they must all return a configuration in the same state than the state at the beginning
	await bundle.describe('search', async feature => {
		await feature.it('filters the tree when the search is typed', async () => {
			//reset tree state to have deterministic display style values
			await driver.click('#tree_collapse_all');

			await driver.type('#tree_search input[name="search"]', 'z');
			await driver.submit('#tree_search');
			//study is displayed but its display attribute has not been updated yet
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST"]', e => e.parentNode.parentNode, {hidden: true}), 'Study is displayed');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS"]', e => e.parentNode.parentNode, {hidden: true}), 'Dataset model "ADDRESS" is displayed');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:ZIPCODE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "ZIPCODE" is displayed');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:PHONE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "PHONE" is hidden');
			//assert.equal(await driver.eval('#tree a[href="#node=Study:TEST|FormModel:CENTER_INIT|Layout:CENTER_INIT_LAYOUT|Line:3|Cell:ZIPCODE"]', e => e.parentNode.parentNode.style.display), 'block', 'Cell "ZIPCODE" is displayed');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST|ScopeModel:CENTER"]', e => e.parentNode.parentNode, {hidden: true}), 'Scope model "CENTER" is hidden');

			await driver.type('#tree_search input[name="search"]', 'zz');
			await driver.submit('#tree_search');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST"]', e => e.parentNode.parentNode, {hidden: true}), 'Study is hidden');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS"]', e => e.parentNode.parentNode, {hidden: true}), 'Dataset model "ADDRESS" is hidden');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:ZIPCODE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "ZIPCODE" is hidden');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:PHONE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "PHONE" is hidden');
			//assert.equal(await driver.eval('#tree a[href="#node=Study:TEST|FormModel:CENTER_INIT|Layout:CENTER_INIT_LAYOUT|Line:3|Cell:ZIPCODE"]', e => e.parentNode.parentNode.style.display), 'none', 'Cell "ZIPCODE" is hidden');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST|ScopeModel:CENTER"]', e => e.parentNode.parentNode, {hidden: true}), 'Scope model "CENTER" is hidden');

			await driver.type('#tree_search input[name="search"]', 'z');
			await driver.submit('#tree_search');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST"]', e => e.parentNode.parentNode, {hidden: true}), 'Study is displayed');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS"]', e => e.parentNode.parentNode, {hidden: true}), 'Dataset model "ADDRESS" is displayed');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:ZIPCODE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "ZIPCODE" is displayed');
			assert.hidden(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:PHONE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "PHONE" is hidden');
		});

		await feature.it('resets the tree when the search is reset', async () => {
			await driver.type('#tree_search input[name="search"]', '');
			await driver.submit('#tree_search');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST"]', e => e.parentNode.parentNode, {hidden: true}), 'Study is displayed');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:ZIPCODE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "ZIPCODE" is displayed');
			assert.visible(await driver.eval('#tree a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:PHONE"]', e => e.parentNode.parentNode, {hidden: true}), 'Field model "PHONE" is displayed');
		});
	});

	await bundle.describe('prevents losing unsaved data', async feature => {
		await feature.it('displays a confirmation message when a form is unsaved', async () => {
			await driver.click('#tree ul.entities > li > ul.workflow > li:nth-child(1) a[href="#node=Study:TEST|Workflow:CENTER_STATUS"]');
			await driver.wait();
			await driver.type(await driver.getShadow('#workflow_shortname', 'input'), 'Center init');
			await driver.click('#tree ul.entities > li > ul.workflow > li:nth-child(15) a[href="#node=Study:TEST|Workflow:VISIT_REPORTING"]');
			await driver.wait();
			assert.open('#validate', 'Confirmation message is displayed when a form with unsaved data is unloaded');
			//stay on page and check that unsaved data are still here
			await driver.click('#validate_buttons > li:first-child > button');
			assert.equal(location.hash, '#node=Study:TEST|Workflow:CENTER_STATUS', 'Form is still displayed if user stays on the page');
			assert.equal(await driver.getValueShadow('#workflow_shortname', 'input'), 'Center init', 'Unsaved data are untouched if the user stays on the page');
			await driver.click('#tree ul.entities > li > ul.workflow > li:nth-child(15) a[href="#node=Study:TEST|Workflow:VISIT_REPORTING"]');
			await driver.wait();
			//leave page
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.getValueShadow('#workflow_shortname', 'input'), 'Visit reporting', 'New data replace unsaved data if user confirms he would like to leave the page');
		});
	});

	await bundle.describe('logs', async feature => {
		await feature.it('displays logs', async () => {
			await driver.click('#menubar > li:nth-child(7) > ul > li:nth-child(3) > button');
			assert.equal(await driver.getStyle('#logs', 'display'), 'flex', 'Logs are displayed after a click on the show log button');
			await driver.click('#tree ul.entities > li > ul.timeline_graph > li:nth-child(1) a[href="#node=Study:TEST|TimelineGraph:PATIENT_OVERVIEW"]');
			await driver.wait();
			await driver.type(await driver.getShadow('#timeline_graph_longname', 'input'), 'Patient timeline overview');
			await driver.submit('#edit_timeline_graph_form');

			assert.equal(await driver.eval('#logs_content > li:last-child', e => e.lastChild.textContent), 'Change longname of TimelineGraph from {} to {"en":"Patient timeline overview"}', 'Last log is a modification of timeline graph longname');
			await driver.type('#timeline_graph_width', 900);
			await driver.submit('#edit_timeline_graph_form');
			assert.equal(await driver.eval('#logs_content > li:last-child', e => e.lastChild.textContent), 'Change width of TimelineGraph from undefined to 900', 'Last log is a modification of timeline graph width');

			await driver.type(await driver.get('#timeline_graph_width'), 850);
			await driver.submit('#edit_timeline_graph_form');
			assert.equal(await driver.eval('#logs_content > li:last-child', e => e.lastChild.textContent), 'Change width of TimelineGraph from 900 to 850', 'Last log is a modification of timeline graph width');

			await driver.click('#logs_close');
			assert.equal(await driver.getStyle('#logs', 'display'), 'none', 'Logs are hidden after a click on the close log button');

			//reset timeline graph in its previous state
			await driver.type(await driver.getShadow('#timeline_graph_longname', 'input'), '');
			await driver.submit('#edit_timeline_graph_form');
		});
	});

	await bundle.describe('keyboard shortcuts', async feature => {
		await feature.it('saves configuration with a keyboard shortcut', async () => {
			assert.closed('#config_save', 'Save configuration window is hidden');
			await driver.press(['c', 's']);
			assert.open('#config_save', 'Save configuration window is displayed after the associated keyboard shortcut has been pressed');
			await driver.click('#config_save_cancel');
		});

		await feature.it('loads a configuration with a keyboard shortcut', async () => {
			assert.closed('#config_load', 'Load configuration window is hidden');
			await driver.press(['c', 'o']);
			assert.open('#config_load', 'Load configuration window is displayed after the associated keyboard shortcut has been pressed');
			await driver.click('#config_load_close');
		});

		await feature.it('displays configuration serialized in JSON with a keyboard shortcut', async () => {
			assert.closed('#study_config', 'JSON configuration is hidden');
			await driver.press(['c', 'v']);
			await driver.wait();
			assert.open('#study_config', 'JSON configuration is displayed after the associated keyboard shortcut has been pressed');
			await driver.click('#study_config_close');
		});

		//download json configuration
		//await driver.press(['c', 'd']);

		await feature.it('shows the log panel with a keyboard shortcut', async () => {
			assert.notEqual(await driver.getStyle('#logs', 'display'), 'flex', 'Log panel is hidden');
			await driver.press(['o', 'l']);
			assert.equal(await driver.getStyle('#logs', 'display'), 'flex', 'Log panel is displayed after the associated keyboard shortcut has been pressed');
			await driver.click('#logs_close');
		});

		await feature.it('shows the transfer window with a keyboard shortcut', async () => {
			assert.closed('#transfer', 'Transfer window is hidden');
			await driver.press(['o', 't']);
			assert.open('#transfer', 'Transfer window is displayed after the associated keyboard shortcut has been pressed');
			await driver.press(['Escape']);
			assert.notEqual(await driver.getStyle('#transfer', 'display'), 'flex', 'Transfer window is hidden');
		});
	});

	await bundle.describe('validator wizard', async feature => {
		await feature.it('creates a validator with all dependencies in the same visit', async () => {
			await driver.click('#menubar > li:nth-child(8) > ul > li:nth-child(2) > button');
			await driver.wait();
			assert.visible('#wizard', 'Wizard is displayed');
			await driver.click('#wizard_start');
			assert.equal(await driver.getTextContent('#wizard_title'), 'New validator', 'Good wizard has been opened');
			await driver.type('#wizard_validator_dataset_model_id', 'RELAPSES_GRID');
			await driver.wait();
			await driver.type('#wizard_validator_field_model_id', 'RLP_DATE_MAX_SEV');
			//click next and wait for the animation to execute
			await driver.click('#wizard_next');
			await driver.wait(500);
			await driver.type('#wizard_validator select[name="wizard_validator_type"]', 'range');
			//click next and wait for the animation to execute
			await driver.click('#wizard_next');
			await driver.wait(500);
			assert.equal(await driver.getValue('#wizard_validator_range input[name="wizard_validator_range_min"]'), '', 'Min range is empty');
			assert.equal(await driver.getValue('#wizard_validator_range input[name="wizard_validator_range_max"]'), '', 'Max range is empty');
			await driver.dragAndDrop('#tree a[href="#node=Study:TEST|DatasetModel:VISIT_DOCUMENTATION|FieldModel:DATE_OF_VISIT"]', '#wizard_validator_range input[name="wizard_validator_range_min"]');
			await driver.dragAndDrop('#tree a[href="#node=Study:TEST|DatasetModel:VISIT_DOCUMENTATION|FieldModel:DATE_OF_WITHDRAWAL"]', '#wizard_validator_range input[name="wizard_validator_range_max"]');
			//click next and wait for the animation to execute
			await driver.click('#wizard_next');
			await driver.wait(500);
			assert.equal(window.location.hash, '#node=Study:TEST|Validator:NEW_VALIDATOR', 'A new validator has been created');
			await driver.click('#wizard_next');
			assert.hidden('#wizard', 'Wizard is displayed');
			await driver.click('#validator_constraint_edit');
			await driver.wait();
			//check generated conditions
			assert.equal(await driver.eval('#rule_conditions > li > ul', e => e.children.length), 0, 'Wizard did not generate any condition on scope');
			assert.equal(await driver.eval('#rule_conditions > li:nth-child(2) > ul', e => e.children.length), 1, 'Wizard generated one condition on event');
			let condition = await driver.get('#rule_conditions > li:nth-child(2) > ul > li');
			assert.equal(condition.id, 'DATASETS_MIN', 'First condition id is "DATASETS_MIN"');
			condition = condition.querySelector('ul > li');
			assert.equal(condition.id, 'DATASET_MIN', 'First condition id is "DATASET_MIN"');
			condition = condition.querySelector('ul > li');
			assert.equal(condition.id, 'FIELDS_MIN', 'First condition id is "FIELDS_MIN"');
			assert.equal(condition.children.length, 2, 'There are two conditions that retrieve a field');
		});

		await feature.it('creates a validator with dependencies in the scope and the event', async () => {
			await driver.click('#menubar > li:nth-child(8) > ul > li:nth-child(2) > button');
			await driver.wait();
			assert.visible('#wizard', 'Wizard is displayed');
			await driver.click('#wizard_start');
			assert.equal(await driver.getTextContent('#wizard_title'), 'New validator', 'Good wizard has been opened');
			await driver.type('#wizard_validator_dataset_model_id', 'RELAPSES_GRID');
			await driver.wait();
			await driver.type('#wizard_validator_field_model_id', 'RLP_DATE_MAX_SEV');
			//click next and wait for the animation to execute
			await driver.click('#wizard_next');
			await driver.wait(500);
			await driver.type('#wizard_validator select[name="wizard_validator_type"]', 'range');
			//click next and wait for the animation to execute
			await driver.click('#wizard_next');
			await driver.wait(500);
			assert.equal(await driver.getValue('#wizard_validator_range input[name="wizard_validator_range_min"]'), '', 'Min range is empty');
			assert.equal(await driver.getValue('#wizard_validator_range input[name="wizard_validator_range_max"]'), '', 'Max range is empty');
			await driver.dragAndDrop('#tree a[href="#node=Study:TEST|DatasetModel:PATIENT_DOCUMENTATION|FieldModel:DATE_OF_FIRST_SYMPTOMS"]', '#wizard_validator_range input[name="wizard_validator_range_min"]');
			await driver.dragAndDrop('#tree a[href="#node=Study:TEST|DatasetModel:VISIT_DOCUMENTATION|FieldModel:DATE_OF_VISIT"]', '#wizard_validator_range input[name="wizard_validator_range_max"]');
			//click next and wait for the animation to execute
			await driver.click('#wizard_next');
			await driver.wait(500);
			assert.equal(window.location.hash, '#node=Study:TEST|Validator:NEW_VALIDATOR_2', 'A new validator has been created');
			await driver.click('#wizard_next');
			assert.hidden('#wizard', 'Wizard is displayed');
			await driver.click('#validator_constraint_edit');
			await driver.wait();
			//check generated conditions
			assert.equal(await driver.eval('#rule_conditions > li > ul', e => e.children.length), 1, 'Wizard generated one condition on scope');
			assert.equal(await driver.eval('#rule_conditions > li:nth-child(2) > ul', e => e.children.length), 1, 'Wizard generated one condition on event');
			let condition = await driver.get('#rule_conditions > li:nth-child(2) > ul > li');
			assert.equal(condition.id, 'DATASETS_MAX', 'First condition id is "DATASETS_MAX"');
			condition = condition.querySelector('ul > li');
			assert.equal(condition.id, 'DATASET_MAX', 'First condition id is "DATASET_MAX"');
			condition = condition.querySelector('ul > li');
			assert.equal(condition.id, 'FIELDS_MAX', 'First condition id is "FIELDS_MAX"');
			condition = condition.querySelector('ul > li');
			assert.equal(condition.id, 'FIELD_MAX', 'First condition id is "FIELD_MAX"');
		});
	});

	await bundle.describe('serialization', async feature => {
		await feature.it('serializes the configuration properly', async () => {
			await driver.click('#tree img[title="Add validator"]');
			//let time for form to load
			await driver.wait();
			await driver.type('#validator_id', 'OLDER_THAN_16');
			await driver.type(await driver.getShadow('#validator_shortname', 'input'), 'Greater than 16 years');
			await driver.type(await driver.getShadow('#validator_message', 'input'), 'This is a test message for a validator');
			await driver.submit('#edit_validator_form');
			//export configuration
			await driver.click('#menubar > li:nth-child(7) > ul > li > button');
			//this takes some time
			await driver.wait();
			assert.open('#study_config', 'Serialized configuration is displayed');
			const configuration = await driver.eval('#study_config_content', e => e.textContent);
			assert.ok(configuration.length > 0, 'Serialized configuration is not empty');
			assert.ok(configuration.includes('OLDER_THAN_16'), 'Serialized configuration contains description of a new validator');
			assert.ok(configuration.includes('This is a test message for a validator'), 'Serialized configuration contains description of a new validator');
			await driver.click('#study_config_close');
			assert.closed('#study_config', 'Serialized configuration is hidden');
		});
	});

	await bundle.describe('consistency check', async feature => {
		await feature.it('shows errors properly', async () => {
			await driver.click('#menubar > li:nth-child(6) > ul > li > a');
			//this takes some time
			await driver.wait();
			assert.open('#consistency_check', 'Consistency check is displayed');
			await driver.click('#consistency_check ul.tabs > li[data-tab="consistency_check_section_errors"]');
			//check errors
			assert.equal(await driver.eval('#consistency_check_section_errors', e => e.children.length), 3, 'There are 3 errors');
			//correct one error
			await driver.click('#consistency_check_section_errors > li > a:last-child');
			assert.equal(await driver.eval('#consistency_check_section_errors', e => e.children.length), 3, 'There are still 3 errors');
			assert.equal(await driver.getStyle('#consistency_check_section_errors > li', 'text-decoration'), 'line-through', 'Error is still displayed and has been fixed');
			//check infos
			await driver.click('#consistency_check ul.tabs > li[data-tab="consistency_check_section_infos"]');
			assert.equal(await driver.eval('#consistency_check_section_infos', e => e.children.length), 1, 'There is 1 information');
			//close report
			await driver.click('#consistency_check menu > li > a.button');
			//this takes some time
			await driver.wait();
			assert.closed('#consistency_check', 'Consistency check is hidden');
			//re-open report to check that error no longer appears
			await driver.click('#menubar > li:nth-child(6) > ul > li > a');
			//this takes some time
			await driver.wait();
			await driver.click('#consistency_check ul.tabs > li[data-tab="consistency_check_section_errors"]');
			assert.equal(await driver.eval('#consistency_check_section_errors', e => e.children.length), 2, '2 errors are displayed after 1 error has been fixed');
			await driver.click('#consistency_check ul.tabs > li[data-tab="consistency_check_section_infos"]');
			assert.equal(await driver.eval('#consistency_check_section_infos', e => e.children.length), 1, 'There is still 1 information');
			await driver.click('#consistency_check menu > li > a.button');
			//this takes some time
			await driver.wait();
		});
	});

	await bundle.describe('layout', async feature => {
		await feature.it('manages layout existence properly', async () => {
			await driver.click('#tree ul.menu > li a[href="#node=Study:TEST|Menu:DASHBOARD"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getStyle('#menu_layout_add', 'display'), 'none', 'Add layout button is hidden');
			assert.equal(await driver.getStyle('#menu_layout_edit', 'display'), '', 'Edit layout button is displayed');
			assert.equal(await driver.getStyle('#menu_layout_delete', 'display'), '', 'Delete layout button is displayed');

			//delete existing layout
			await driver.click('#menu_layout_delete');
			await driver.click('#validate_buttons > li:last-child > button');

			assert.equal(await driver.getStyle('#menu_layout_add', 'display'), '', 'Add layout button is displayed');
			assert.equal(await driver.getStyle('#menu_layout_edit', 'display'), 'none', 'Edit layout button is hidden');
			assert.equal(await driver.getStyle('#menu_layout_delete', 'display'), 'none', 'Delete layout button is hidden');

			await driver.click('#menu_layout_add');
			await driver.wait();
			assert.equal(await driver.eval('#layout_sections', e => e.children.length), 1, 'There is 1 tab');
		});

		await feature.it('displays layout section', async () => {
			//section detail
			await driver.click('#layout_sections > li > a[title="Edit section"]');
			await driver.wait();
			assert.equal(await driver.getStyle('#edit_cms_section', 'display'), 'flex', 'Section details form is displayed');
			assert.equal(await driver.getValue('#cms_section_id'), 'SECTION_1', 'First section id is "SECTION_1"');
			await driver.type('#cms_section_id', 'QUERIES');
			assert.equal(await driver.getValueShadow('#cms_section_labels', 'input'), '', 'First section label is empty');
			await driver.type(await driver.getShadow('#cms_section_labels', 'input'), 'Queries');
			//section detail right
			assert.equal(await driver.getValue('#cms_section_required_feature'), '', 'Required feature is empty');
			assert.selectContains('#cms_section_required_feature', 'EXPORT', 'Required feature select contains "EXPORT"');
			assert.selectContains('#cms_section_required_feature', 'DOCUMENTATION', 'Required feature select contains "DOCUMENTATION"');
			assert.equal(await driver.getValue('#cms_section_required_right_entity'), '', 'Required right entity is empty');
			assert.selectContains('#cms_section_required_right_entity', 'SCOPE_MODEL', 'Required right entity contains "SCOPE_MODEL"');
			assert.selectContains('#cms_section_required_right_entity', 'PROFILE', 'Required right entity contains "PROFILE"');
			assert.selectNotContains('#cms_section_required_right_entity', 'MENU', 'Required right entity does not contain "MENU"');
			assert.equal(await driver.eval('#cms_section_required_right_id', e => e.children.length), 1, 'Required right entity id is empty');
			await driver.type('#cms_section_required_right_entity', 'SCOPE_MODEL');
			assert.equal(await driver.eval('#cms_section_required_right_id', e => e.children.length), 6, 'Required right entity contains 6 options');
			assert.selectContains('#cms_section_required_right_id', 'COUNTRY', 'Required right entity id contains "COUNTRY"');
			assert.selectContains('#cms_section_required_right_id', 'PATIENT', 'Required right entity id contains "PATIENT"');
			assert.selectContains('#cms_section_required_right_id', 'CENTER', 'Required right entity id contains "CENTER"');
			assert.selectNotContains('#cms_section_required_right_id', 'ADMIN', 'Required right entity id does not contain "ADMIN"');
			await driver.type('#cms_section_required_right_id', 'PATIENT');
			assert.selectContains('#cms_section_required_right_right', 'READ', 'Required right contains "READ"');
			assert.selectContains('#cms_section_required_right_right', 'WRITE', 'Required right contains "WRITE"');
			await driver.type('#cms_section_required_right_right', 'READ');
			await driver.submit('#edit_cms_section_form');
			//let time for form to close
			await driver.wait();
			//check modifications in model
			assert.equal(Router.selectedNode.sections.length, 1, 'There is 1 section in selected menu');
			const section = Router.selectedNode.sections[0];
			assert.equal(section.widgets.length, 0, 'First section does not contain any widget');
			assert.equal(section.id, 'QUERIES', 'First section id is "QUERIES"');
			assert.equal(section.getLocalizedLabel(selected_language), 'Queries', 'First section label is "Queries"');
			assert.undefined(section.requiredFeature, 'First section required feature is undefined');
			assert.equal(section.requiredRight.rightEntity, 'SCOPE_MODEL', 'First section required right entity is "SCOPE_MODEL"');
			assert.equal(section.requiredRight.id, 'PATIENT', 'First section required right id is "PATIENT"');
			assert.equal(section.requiredRight.right, 'READ', 'First section required right is "READ"');

			//check modifications in ui
			await driver.click('#layout_sections > li > a[title="Edit section"]');
			await driver.wait();
			assert.equal(await driver.getValue('#cms_section_id'), 'QUERIES', 'First section id is "QUERIES"');
			assert.equal(await driver.getValueShadow('#cms_section_labels', 'input'), 'Queries', 'First section label is "Queries"');
			assert.equal(await driver.getValue('#cms_section_required_feature'), '', 'Required feature is empty');
			assert.equal(await driver.getValue('#cms_section_required_right_entity'), 'SCOPE_MODEL', 'Required right entity is "SCOPE_MODEL"');
			assert.equal(await driver.getValue('#cms_section_required_right_id'), 'PATIENT', 'Required right entity id is "PATIENT"');
			assert.equal(await driver.getValue('#cms_section_required_right_right'), 'READ', 'Required right is "READ"');
			await driver.click('#edit_cms_section_close');
			//let time for form to close
			await driver.wait();
			//add widget
			await driver.dragAndDrop(driver.getByText('#layout_widgets_types', 'Workflow'), '#layout_widgets');
			//check modifications in model
			assert.equal(section.widgets.length, 1, 'First section contains 1 widget');
			assert.equal(section.widgets[0].type, 'WORKFLOW', 'First widget id is "WORKFLOW"');
			//check modifications in ui
			assert.equal(await driver.eval('#layout_widgets', e => e.children.length), 1, 'There is 1 widget in section');
			assert.equal(document.querySelectorAll('#layout_widgets > div > p').length, 1, 'There is 1 parameters for first widget');

			//widget detail
			await driver.click('#layout_widgets > div > h3 > a[title="Edit widget"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getStyle('#edit_cms_widget', 'display'), 'flex', 'Widget details form is displayed');
			await driver.type('#cms_widget_width', '700');
			await driver.type('#cms_widget_text_before', 'Workflows');
			//widget detail right
			assert.equal(await driver.getValue('#cms_widget_required_feature'), '', 'Required feature is empty');
			assert.selectContains('#cms_widget_required_feature', 'ADMIN', 'Required feature select contains "ADMIN"');
			assert.selectContains('#cms_widget_required_feature', 'MANAGE_DELETED_DATA', 'Required feature select contains "MANAGE_DELETED_DATA"');
			await driver.type('#cms_widget_required_feature', 'EXPORT');
			assert.equal(await driver.getValue('#cms_widget_required_right_entity'), '', 'Required right entity is empty');
			assert.selectContains('#cms_widget_required_right_entity', 'SCOPE_MODEL', 'Required right entity contains "SCOPE_MODEL"');
			assert.selectContains('#cms_widget_required_right_entity', 'PROFILE', 'Required right entity contains "PROFILE"');
			assert.selectNotContains('#cms_widget_required_right_entity', 'WORKFLOW', 'Required right entity does not contain "WORKFLOW"');
			assert.equal(await driver.eval('#cms_widget_required_right_id', e => e.children.length), 1, 'Required right entity id is empty');
			await driver.type('#cms_widget_required_right_entity', 'SCOPE_MODEL');
			assert.equal(await driver.eval('#cms_widget_required_right_id', e => e.children.length), 6, 'Required right entity contains 6 options');
			assert.selectContains('#cms_widget_required_right_id', 'COUNTRY', 'Required right entity id contains "COUNTRY"');
			assert.selectContains('#cms_widget_required_right_id', 'PATIENT', 'Required right entity id contains "PATIENT"');
			assert.selectContains('#cms_widget_required_right_id', 'CENTER', 'Required right entity id contains "CENTER"');
			assert.selectNotContains('#cms_widget_required_right_id', 'ADMIN', 'Required right entity id does not contain "ADMIN"');
			await driver.type('#cms_widget_required_right_id', 'PATIENT');
			assert.selectContains('#cms_widget_required_right_right', 'READ', 'Required right contains "READ"');
			assert.selectContains('#cms_widget_required_right_right', 'WRITE', 'Required right contains "WRITE"');
			await driver.type('#cms_widget_required_right_right', 'READ');
			await driver.submit('#edit_cms_widget_form');

			//check modifications in model
			const widget = Router.selectedNode.sections[0].widgets[0];
			assert.equal(widget.textBefore, 'Workflows', 'First widget text before is "Workflows"');
			assert.equal(widget.requiredFeature, 'EXPORT', 'First widget required feature is "EXPORT"');
			assert.equal(widget.requiredRight.rightEntity, 'SCOPE_MODEL', 'First section required right entity is "SCOPE_MODEL"');
			assert.equal(widget.requiredRight.id, 'PATIENT', 'First section required right id is "PATIENT"');
			assert.equal(widget.requiredRight.right, 'READ', 'First section required right is "READ"');

			//check modifications in ui
			await driver.click('#layout_widgets > div > h3 > a[title="Edit widget"]');
			await driver.wait();
			assert.equal(await driver.getValue('#cms_widget_text_before'), 'Workflows', 'First widget text before is "Workflows"');
			assert.equal(await driver.getValue('#cms_widget_required_feature'), 'EXPORT', 'Required feature is "EXPORT"');
			assert.equal(await driver.getValue('#cms_widget_required_right_entity'), 'SCOPE_MODEL', 'Required right entity is "SCOPE_MODEL"');
			assert.equal(await driver.getValue('#cms_widget_required_right_id'), 'PATIENT', 'Required right entity id is "PATIENT"');
			assert.equal(await driver.getValue('#cms_widget_required_right_right'), 'READ', 'Required right is "READ"');
			await driver.click('#edit_cms_widget_close');
			//let time for form to close
			await driver.wait();
			await driver.submit('#layout_composition');
			//let time for form to close
			await driver.wait();
			assert.equal(await driver.getStyle('#menu_layout_add', 'display'), 'none', 'Add layout button is hidden');
			assert.equal(await driver.getStyle('#menu_layout_edit', 'display'), '', 'Edit layout button is displayed');
			assert.equal(await driver.getStyle('#menu_layout_delete', 'display'), '', 'Delete layout button is displayed');
			await driver.click('#menu_layout_delete');
			await driver.click('#validate_buttons > li:last-child > button');

			assert.equal(await driver.getStyle('#menu_layout_add', 'display'), '', 'Add layout button is displayed');
			assert.equal(await driver.getStyle('#menu_layout_edit', 'display'), 'none', 'Edit layout button is hidden');
			assert.equal(await driver.getStyle('#menu_layout_delete', 'display'), 'none', 'Delete layout button is hidden');
		});
	});

	await bundle.describe('rules', async feature => {
		await feature.it('displays triggers', async () => {
			//trigger
			await driver.click('#menubar > li:nth-child(5) > ul > li:nth-child(16) > a');

			await driver.wait();
			assert.equal(await driver.getStyle('#trigger', 'display'), 'block', 'Trigger section is visible');
			assert.equal(await driver.eval('#trigger > div > h2', e => e.textContent), 'Study Test study for Rodano > User logged in', 'Trigger name is "Study Test study for Rodano > User logged in"');
			assert.equal(await driver.eval('#trigger_rules > ul', e => e.childNodes.length), 0, 'There is 0 rule for trigger "USER_LOGIN"');
		});

		await feature.it('manages rule properly', async () => {
			await driver.click('#trigger_rules > button');
			//let time to select node
			await driver.wait();
			assert.equal(await driver.getValue('#rule_description'), 'Rule 1', 'New rule created is "Rule 1"');
			assert.notOk(await driver.eval('#rule_conditions > li', e => e.classList.contains('disabled')), 'Root entity SCOPE is enabled');
			assert.ok(await driver.eval('#rule_conditions > li:nth-child(2)', e => e.classList.contains('disabled')), 'Root entity EVENT is disabled');
			assert.ok(await driver.eval('#rule_conditions > li:nth-child(5)', e => e.classList.contains('disabled')), 'Root entity FORM is disabled');
			assert.equal(await driver.eval('#rule_conditions > li > div', e => e.firstChild.textContent), 'Scope', 'First root entity name is "scope"');

			//cancel rule
			await driver.click('#rule_cancel');

			//let time to unselect rule
			await driver.wait();
			//cancel rule does not remove it from rule
			assert.equal(await driver.eval('#trigger_rules > ul', e => e.childNodes.length), 1, 'There is 1 rule for trigger "USER_LOGIN"');
			await driver.click('#trigger_rules > ul > li > img[title="Delete rule"]');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#trigger_rules > ul', e => e.childNodes.length), 0, 'There is 0 rule for trigger "USER_LOGIN"');

			await driver.click('#tree ul.workflow > li:nth-child(8) > ul.entities > li:nth-child(2) > ul.action > li:nth-child(2) a[href="#node=Study:TEST|Workflow:QUERY|Action:CLOSE_QUERY"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.eval('#action_rules > ul', e => e.childNodes.length), 1, 'There is 1 rule for action "CLOSE_QUERY"');

			//let time to select node
			await driver.wait();
			await driver.click('#action_rules > button');

			//rule
			assert.equal(await driver.getValue('#rule_description'), 'Rule 2', 'New rule created is "Rule 2"');
			await driver.type('#rule_description', 'Do something when a query is closed');
			//check only available root entities have been activated
			assert.notOk(await driver.eval('#rule_conditions > li', e => e.classList.contains('disabled')), 'Root entity SCOPE is enabled');
			assert.notOk(await driver.eval('#rule_conditions > li:nth-child(2)', e => e.classList.contains('disabled')), 'Root entity EVENT is enabled');
			assert.notOk(await driver.eval('#rule_conditions > li:nth-child(5)', e => e.classList.contains('disabled')), 'Root entity FORM is enabled');
			assert.equal(await driver.eval('#rule_conditions > li > div', e => e.firstChild.textContent), 'Scope', 'First root entity name is "scope"');

			//add a condition
			assert.equal(await driver.eval('#rule_conditions > li > ul', e => e.childNodes.length), 0, 'There is 0 condition for root entity SCOPE');
			await driver.click('#rule_conditions > li > div > img');
			assert.equal(await driver.eval('#rule_conditions > li > ul', e => e.childNodes.length), 1, 'There is 1 condition for root entity SCOPE');
			//assert.equal(await driver.get('#rule_conditions > li > ul > li'), await driver.get('#11'), 'First rule is rule with id 11');
			let condition = await driver.get('#rule_conditions > li > ul > li');
			assert.equal(condition.id, '11', 'First condition id is "11"');
			assert.selectContains(condition.querySelector('select[name="property"]'), 'ANCESTOR', 'Property "ANCESTOR" is available for first condition');
			assert.selectContains(condition.querySelector('select[name="property"]'), 'EVENT', 'Property "EVENT" is available for first condition');
			assert.selectNotContains(condition.querySelector('select[name="property"]'), 'FIELD', 'Property "FIELD" is not available for first condition');
			//change property
			assert.equal(condition.querySelector('select[name="operator"]').style.display, 'none', 'Operator is hidden');
			assert.equal(condition.querySelector('div > div').style.display, 'none', 'Value container is hidden');
			await driver.type(condition.querySelector('select[name="property"]'), 'CODE');
			assert.equal(condition.querySelector('select[name="operator"]').style.display, 'block', 'Operator is visible');
			assert.equal(condition.querySelector('div > div').style.display, 'none', 'Value container is hidden');
			assert.equal(condition.querySelector('select[name="operator"]').value, '', 'Operator has not been selected yet');
			assert.selectContains(condition.querySelector('select[name="operator"]'), 'EQUALS', 'Operator "EQUALS" is available for property "CODE"');
			assert.selectContains(condition.querySelector('select[name="operator"]'), 'NOT_EQUALS', 'Operator "NOT_EQUALS" is available for property "CODE"');
			assert.selectContains(condition.querySelector('select[name="operator"]'), 'CONTAINS', 'Operator "CONTAINS" is available for property "CODE"');
			assert.selectNotContains(condition.querySelector('select[name="operator"]'), 'GREATER', 'Operator "GREATER" is not available for property "CODE"');
			assert.equal(condition.querySelector('div > div > div').childNodes.length, 0, 'Value container is empty');
			await driver.type(condition.querySelector('select[name="operator"]'), 'CONTAINS');
			assert.equal(condition.querySelector('div > div > div').childNodes.length, 1, 'Value container has 1 child');
			await driver.type(condition.querySelector('input[name="value"]'), 'FR');
			//add children conditions
			await driver.click(condition.querySelector('img[title="Add a condition"]'));
			condition = condition.querySelector('ul > li');
			await driver.type(condition.querySelector('select[name="property"]'), 'DATASET');
			await driver.click(condition.querySelector('img[title="Add a condition"]'));
			condition = condition.querySelector('ul > li');
			await driver.type(condition.querySelector('select[name="property"]'), 'ID');
			await driver.type(condition.querySelector('select[name="operator"]'), 'EQUALS');
			await driver.type(condition.querySelector('select[name="value"]'), 'PATIENT_DOCUMENTATION');
			await driver.click(condition.querySelector('img[title="Add a condition"]'));
			condition = condition.querySelector('ul > li');
			await driver.type(condition.querySelector('select[name="property"]'), 'FIELD');
			await driver.click(condition.querySelector('img[title="Add a condition"]'));
			condition = condition.querySelector('ul > li');
			await driver.type(condition.querySelector('select[name="property"]'), 'ID');
			await driver.type(condition.querySelector('select[name="operator"]'), 'EQUALS');
			await driver.type(condition.querySelector('select[name="value"]'), 'GENDER');
			assert.ok(document.getElementById('11111') !== null, 'There is one condition with id "11111"');
			//change condition id
			let condition_id = condition.querySelector('span.rule_condition_id');
			condition_id.textContent = 'GENDER';
			let event = new FocusEvent('blur', {bubbles: true, cancelable: true});
			condition_id.dispatchEvent(event);

			//add static action
			let rule_actions = document.getElementById('rule_actions');
			assert.equal(rule_actions.childNodes.length, 0, 'There is 0 action');
			await driver.click('#rule_action_add');
			assert.equal(rule_actions.childNodes.length, 1, 'There is 1 action');
			let rule_action = rule_actions.children[0];
			assert.selectContains(rule_action.querySelector('select[name="type"]'), 'ENTITY_ACTION', 'Action type contains "ENTITY_ACTION"');
			assert.selectContains(rule_action.querySelector('select[name="type"]'), 'STATIC_ACTION', 'Action type contains "STATIC_ACTION"');
			assert.selectContains(rule_action.querySelector('select[name="type"]'), 'CONFIGURATION_ACTION', 'Action type contains "CONFIGURATION_ACTION"');
			/**@type {NodeListOf<HTMLSpanElement>}*/
			const action_blocks = rule_action.querySelectorAll('div > span');
			assert.equal(action_blocks[0].style.display, 'none', 'Condition action block is hidden');
			assert.equal(action_blocks[1].style.display, 'none', 'Static action block is hidden');
			assert.equal(action_blocks[2].style.display, 'none', 'Configuration action block is hidden');
			//chose static action
			await driver.type(rule_action.querySelector('select[name="type"]'), 'STATIC_ACTION');
			assert.equal(action_blocks[0].style.display, 'none', 'Condition action block is hidden');
			assert.equal(action_blocks[1].style.display, 'inline', 'Static action block is displayed');
			assert.equal(action_blocks[2].style.display, 'none', 'Configuration action block is hidden');
			assert.selectContains(rule_action.querySelector('select[name="static_action"]'), 'LOG', 'Action select contains "LOG"');
			assert.selectNotContains(rule_action.querySelector('select[name="static_action"]'), 'CHANGE_CODE', 'Action select does not contain "CHANGE_CODE"');
			await driver.type(rule_action.querySelector('select[name="static_action"]'), 'LOG');
			await driver.type(rule_action.querySelector('div:nth-child(3) > p > textarea'), 'Query closed');

			//add condition action
			await driver.click('#rule_action_add');
			assert.equal(rule_actions.childNodes.length, 2, 'There are 2 actions');
			rule_action = rule_actions.children[1];
			await driver.type(rule_action.querySelector('select[name="type"]'), 'ENTITY_ACTION');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), '11', 'Condition select contains "11"');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), '111', 'Condition select contains "111"');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), 'SCOPE', 'Condition select contains "SCOPE"');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), 'FIELD', 'Condition select contains "FIELD"');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), 'FORM', 'Condition select contains "FORM"');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), 'WORKFLOW', 'Condition select contains "WORKFLOW"');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), 'GENDER', 'Condition select contains "GENDER"');
			assert.selectNotContains(rule_action.querySelector('select[name="condition"]'), '111111', 'Condition select does not contain "111111"');

			//add children condition
			await driver.click(condition.querySelector('img[title="Add a condition"]'));
			condition = condition.querySelector('ul > li');
			await driver.type(condition.querySelector('select[name="property"]'), 'VALUE');
			await driver.type(condition.querySelector('select[name="operator"]'), 'NOT_EQUALS');
			//add two values
			let values_container = condition.querySelector('div > div > div');
			await driver.type(values_container.firstElementChild.firstElementChild, 'M');
			await driver.click(condition.querySelector('img[title="Add value"]'));
			await driver.type(values_container.lastElementChild.firstElementChild, 'F');

			//add an other condition
			await driver.click('#rule_conditions > li > div > img');
			condition = await driver.get('#rule_conditions > li > ul > li:nth-child(2)');
			await driver.type(condition.querySelector('select[name="property"]'), 'EVENT');
			await driver.click(condition.querySelector('img[title="Add a condition"]'));
			condition = condition.querySelector('ul > li');
			await driver.type(condition.querySelector('select[name="property"]'), 'ID');
			await driver.type(condition.querySelector('select[name="operator"]'), 'EQUALS');
			await driver.type(condition.querySelector('select[name="value"]'), 'BASELINE');

			assert.notNull(document.getElementById('12'), 'There is one condition with id "12"');
			assert.notNull(document.getElementById('121'), 'There is one condition with id "121"');

			assert.selectContains(rule_action.querySelector('select[name="condition"]'), '12', 'Condition select contains "12"');
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), '121', 'Condition select contains "121"');
			await driver.type(rule_action.querySelector('select[name="condition"]'), '121');
			await driver.type(rule_action.querySelector('select[name="condition_action"]'), 'ADD_FORM');

			//change condition id
			condition_id = condition.querySelector('span.rule_condition_id');
			condition_id.textContent = 'BASELINE';
			event = new FocusEvent('blur', {bubbles: true, cancelable: true});
			condition_id.dispatchEvent(event);
			assert.selectContains(rule_action.querySelector('select[name="condition"]'), 'BASELINE', 'Condition select contains "BASELINE"');
			assert.equal(rule_action.querySelector('select[name="condition"]').value, 'BASELINE', '"BASELINE" is selected in condition select');

			//set parameters value
			assert.selectContains(rule_action.querySelector('div:nth-child(3) > p > select'), 'CENTER_INFORMATION', 'Action parameter select contains "CENTER_INFORMATION"');
			assert.selectContains(rule_action.querySelector('div:nth-child(3) > p > select'), 'EDSS', 'Action parameter select contains "EDSS"');
			assert.selectContains(rule_action.querySelector('div:nth-child(3) > p > select'), 'SF_36', 'Action parameter select contains "SF_36"');
			await driver.type(rule_action.querySelector('div:nth-child(3) > p > select'), 'RELAPSES');
			await driver.submit('#rule');

			//let time to unselect rule
			await driver.wait();
			assert.equal(await driver.eval('#action_rules > ul', e => e.childNodes.length), 2, 'There are 2 rules for action "CLOSE_QUERY"');
			assert.equal(await driver.eval('#action_rules > ul > li:last-child > a', e => e.textContent), 'Do something when a query is closed', 'Rule name is "Do something when a query is closed"');
			await driver.click('#action_rules > ul > li:last-child > a');

			//let time to select rule
			await driver.wait();
			//check rule conditions
			assert.notOk(await driver.eval('#rule_conditions > li', e => e.classList.contains('disabled')), 'Root entity SCOPE is enabled');
			assert.notOk(await driver.eval('#rule_conditions > li:nth-child(2)', e => e.classList.contains('disabled')), 'Root entity EVENT is enabled');
			assert.equal(await driver.eval('#rule_conditions > li > ul', e => e.childNodes.length), 2, 'There is 2 conditions for root entity SCOPE');
			assert.equal(await driver.eval('#rule_conditions > li:nth-child(2) > ul', e => e.childNodes.length), 0, 'There is 0 condition for root entity EVENT');
			condition = await driver.get('#rule_conditions > li > ul > li');
			assert.equal(condition.id, '11', 'First condition id is "11"');
			assert.equal(condition.querySelector('div > select[name="property"]').value, 'CODE', 'First condition property is "CODE"');
			assert.equal(condition.querySelector('div > select[name="property"]').value, 'CODE', 'First condition property is "CODE"');
			assert.equal(condition.querySelector('div > select[name="operator"]').value, 'CONTAINS', 'First condition operator is "CONTAINS"');
			assert.equal(condition.querySelector('div input[name="value"]').value, 'FR', 'First condition value is "FR"');
			condition = condition.lastElementChild.firstElementChild;
			condition = condition.lastElementChild.firstElementChild;
			condition = condition.lastElementChild.firstElementChild;
			condition = condition.lastElementChild.firstElementChild;
			assert.equal(condition.id, 'GENDER', 'Id of condition on GENDER is "GENDER"');
			assert.equal(condition.firstElementChild.querySelector('select[name="operator"]').value, 'EQUALS', 'Condition operator is "EQUALS"');
			assert.equal(condition.firstElementChild.querySelector('select[name="value"]').value, 'GENDER', 'Condition value is "GENDER"');
			condition = condition.querySelector('ul > li');
			assert.equal(condition.querySelector('div > select[name="operator"]').value, 'NOT_EQUALS', 'Condition operator is "NOT_EQUALS"');
			values_container = condition.querySelector('div > div > div');
			assert.equal(values_container.childNodes.length, 2, 'There are 2 values for condition');
			assert.equal(values_container.firstElementChild.firstElementChild.value, 'M', 'First value is "M"');
			assert.equal(values_container.lastElementChild.firstElementChild.value, 'F', 'Second value is "F"');
			//check actions
			rule_actions = document.getElementById('rule_actions');
			assert.equal(rule_actions.childNodes.length, 2, 'There are 2 actions');
			rule_action = rule_actions.children[0];
			assert.equal(rule_action.querySelector('select[name="type"]').value, 'STATIC_ACTION', 'First action is a global action');
			assert.equal(rule_action.querySelector('select[name="static_action"]').value, 'LOG', 'First action is "LOG"');
			assert.equal(rule_action.querySelector('div:nth-child(3) > p > textarea').value, 'Query closed', 'First parameter for first action is "Query closed"');
			rule_action = rule_actions.children[1];
			assert.equal(rule_action.querySelector('select[name="type"]').value, 'ENTITY_ACTION', 'Second action use a selection');
			assert.equal(rule_action.querySelector('select[name="condition"]').value, 'BASELINE', 'Second action use selection "BASELINE"');
			assert.equal(rule_action.querySelector('select[name="condition_action"]').value, 'ADD_FORM', 'Second action is "ADD_FORM"');
			assert.equal(rule_action.querySelector('div:nth-child(3) > p:first-of-type > select').value, 'RELAPSES', 'First parameter for second action is "Center initiation"');
			await driver.click('#rule_cancel');

			await driver.wait();
			assert.equal(await driver.eval('#action_rules > ul', e => e.childNodes.length), 2, 'There are 2 rules for action "CLOSE_QUERY"');
			//duplicate rule
			await driver.click('#action_rules > ul > li:last-child > img[title="Duplicate rule"]');

			//let time to select rule
			await driver.wait();
			assert.equal(await driver.getValue('#rule_description'), 'Do something when a query is closed (copy)', 'Duplicated rule is "Do something when a query is closed (copy)"');
			await driver.type('#rule_description', 'Do something else');
			//test conditions have been duplicated
			condition = document.getElementById('GENDER1');
			assert.equal(condition.querySelector('div > select[name="property"]').value, 'VALUE', 'Condition property is "VALUE"');
			assert.equal(condition.querySelector('div > select[name="operator"]').value, 'NOT_EQUALS', 'Condition operator is "NOT_EQUALS"');
			values_container = condition.querySelector('div > div > div');
			assert.equal(values_container.childNodes.length, 2, 'There are 2 values for condition');
			assert.equal(values_container.firstElementChild.firstElementChild.value, 'M', 'First value is "M"');
			assert.equal(values_container.lastElementChild.firstElementChild.value, 'F', 'Second value is "F"');
			//test actions have been duplicated
			rule_actions = document.getElementById('rule_actions');
			assert.equal(rule_actions.childNodes.length, 2, 'There are 2 actions');
			rule_action = rule_actions.children[1];
			assert.equal(rule_action.querySelector('select[name="type"]').value, 'ENTITY_ACTION', 'Second action use a selection');
			assert.equal(rule_action.querySelector('select[name="condition"]').value, 'BASELINE', 'Second action use selection "BASELINE"');
			assert.equal(rule_action.querySelector('select[name="condition_action"]').value, 'ADD_FORM', 'Second action is "ADD_FORM"');
			assert.equal(rule_action.querySelector('div:nth-child(3) > p:first-of-type > select').value, 'RELAPSES', 'First parameter for second action is "Center initiation"');
			await driver.submit('#rule');

			//let time to unselect rule
			await driver.wait();
			assert.equal(await driver.eval('#action_rules > ul', e => e.childNodes.length), 3, 'There are 3 rules for action "CLOSE_QUERY"');
			assert.equal(await driver.eval('#action_rules > ul > li:nth-child(2)', e => e.textContent), 'Do something when a query is closed', 'First rule description is "Do something when a query is closed"');
			assert.equal(await driver.eval('#action_rules > ul > li:last-child', e => e.textContent), 'Do something else', 'Second rule description is "Do something else"');

			//delete rules
			await driver.click('#action_rules > ul > li:nth-child(2) > img[title="Delete rule"]');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#action_rules > ul', e => e.childNodes.length), 2, 'There are 2 rules for action "CLOSE_QUERY"');
			assert.equal(await driver.eval('#action_rules > ul > li:last-child', e => e.textContent), 'Do something else', 'Last rule description is now "Do something else"');
			await driver.click('#action_rules > ul > li:last-child > img[title="Delete rule"]');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#trigger_rules > ul', e => e.childNodes.length), 0, 'There is 1 rule for action "CLOSE_QUERY"');
		});
	});

	await bundle.describe('constraints', async feature => {
		await feature.it('manages constraint properly', async () => {
			//layout
			await driver.click('#tree ul.entities > li > ul.form_model > li:nth-child(10) a[href="#node=Study:TEST|FormModel:MS_HISTORY"]');
			await driver.wait();
			await driver.click('#form_model_layouts > div > h3 > a[title="Edit layout"]');
			await driver.wait();
			assert.equal(await driver.getValue('#layout_id'), 'HISTORY', 'Layout id is "HISTORY"');

			//layout constraint
			assert.equal(await driver.getStyle('#layout_constraint_add', 'display'), '', 'There is no constraint for this layout');
			assert.equal(await driver.getStyle('#layout_constraint_edit', 'display'), 'none', 'There is no constraint for this layout');
			assert.equal(await driver.getStyle('#layout_constraint_delete', 'display'), 'none', 'There is no constraint for this layout');
			await driver.click('#layout_constraint_add');

			//let time to select constraint
			await driver.wait();
			await driver.click('#rule_cancel');

			//let time to unselect constraint
			await driver.wait();
			assert.equal(await driver.getStyle('#layout_constraint_add', 'display'), 'none', 'There is a constraint for this layout');
			assert.equal(await driver.getStyle('#layout_constraint_edit', 'display'), '', 'There is a constraint for this layout');
			assert.equal(await driver.getStyle('#layout_constraint_delete', 'display'), '', 'There is a constraint for this layout');
			await driver.click('#layout_constraint_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.getStyle('#layout_constraint_add', 'display'), '', 'There is no constraint for this layout');
			assert.equal(await driver.getStyle('#layout_constraint_edit', 'display'), 'none', 'There is no constraint for this layout');
			assert.equal(await driver.getStyle('#layout_constraint_delete', 'display'), 'none', 'There is no constraint for this layout');

			await driver.click('#edit_layout_close');
			await driver.wait();
		});
	});

	/*await bundle.describe('copy paste', async feature => {
		await feature.it('works properly', async () => {
			//reset clipboard
			navigator.clipboard.writeText('');
			const study = StudyHandler.GetStudy();
			const copied_node = study.getDatasetModel('ADDRESS').getFieldModel('ADDRESS_1');
			//copy node
			assert.hidden(await driver.get('#node_menu', {hidden: true}), 'Node menu is hidden');
			await driver.contextMenu('#tree ul.dataset_model > li:nth-child(1) > ul.field_model a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:ADDRESS_1"]');
			await driver.wait();
			assert.visible(await driver.get('#node_menu'), 'Node menu is displayed after a right click on a node');
			assert.ok(await driver.eval('#node_menu_paste', e => e.disabled), 'Paste option is disabled');
			await driver.click('#node_menu_copy');
			assert.hidden(await driver.get('#node_menu', {hidden: true}), 'Node menu is hidden');
			//try to paste in a node
			await driver.contextMenu('#tree ul.event a[href="#node=Study:TEST|ScopeModel:PATIENT|Event:BASELINE"]');
			await driver.wait();
			assert.visible(await driver.get('#node_menu'), 'Node menu is displayed');
			assert.ok(await driver.eval('#node_menu_paste', e => e.disabled), 'Paste option is disabled');
			//try to paste in an other node
			await driver.contextMenu('#tree ul.dataset_model a[href="#node=Study:TEST|DatasetModel:ADDRESS"]');
			await driver.wait();
			assert.visible(await driver.get('#node_menu'), 'Node menu is displayed');
			assert.ok(await driver.eval('#node_menu_paste', e => !e.disabled), 'Paste option is enabled');
			assert.equal(await driver.eval('#tree ul.dataset_model > li:nth-child(1) > ul.field_model', e => e.children.length), 7, 'There are 7 field models in dataset model "ADDRESS"');
			await driver.click('#node_menu_paste');
			await driver.wait();
			assert.equal(await driver.eval('#tree ul.dataset_model > li:nth-child(1) > ul.field_model', e => e.children.length), 8, 'There are 8 field models in dataset model "ADDRESS" after one has been pasted');
			//check pasted node in model
			const pasted_node = study.getDatasetModel('ADDRESS').getFieldModel('COPY_ADDRESS_1');
			assert.notEqual(copied_node, pasted_node, 'Pasted node is not the same than copied node');
			assert.equal(pasted_node.id, 'COPY_ADDRESS_1', 'Pasted node id is "COPY_ADDRESS_1"');
			assert.equal(pasted_node.id, `COPY_${copied_node.id}`, 'Pasted node id is the id of copied node prefixed by "COPY_"');
			assert.equal(pasted_node.getLocalizedShortname(selected_language), 'Address 1', 'Pasted node shortname is "Address 1"');
			assert.equal(pasted_node.getLocalizedShortname(selected_language), copied_node.getLocalizedShortname(selected_language), 'Pasted node shortname is the same than copied node shortname');
			//check pasted node in ui
			await driver.click('#tree ul.dataset_model > li:nth-child(1) > ul.field_model a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:COPY_ADDRESS_1"]');
			await driver.wait();
			assert.equal(await driver.getValue('#field_model_id'), 'COPY_ADDRESS_1', 'Pasted node id is "COPY_ADDRESS_1"');
			assert.equal(await driver.getValueShadow('#field_model_shortname', 'input'), 'Address 1', 'Pasted node shortname is "Address 1"');
			//check node can be pasted again
			await driver.contextMenu('#tree ul.dataset_model a[href="#node=Study:TEST|DatasetModel:ADDRESS"]');
			await driver.wait();
			assert.notOk(await driver.eval('#node_menu_paste', e => e.disabled), 'Paste option is still enabled');
			//modify node
			await driver.type(await driver.get('#field_model_id'), 'CENTER_ADDRESS_3');
			await driver.type(await driver.getShadow('#field_model_shortname', 'input'), 'Address 3');
			await driver.submit('#edit_field_model_form');
			//check modifications in model
			assert.equal(pasted_node.id, 'CENTER_ADDRESS_3', 'Pasted node id is now "CENTER_ADDRESS_3"');
			assert.equal(pasted_node.getLocalizedShortname(selected_language), 'Address 3', 'Pasted node shortname is now "Address 3"');
			assert.equal(copied_node.getLocalizedShortname(selected_language), 'Address 1', 'Copied node shortname has not been changed');
			//check node can be pasted again
			await driver.contextMenu('#tree ul.dataset_model a[href="#node=Study:TEST|DatasetModel:ADDRESS"]');
			assert.notOk(await driver.eval('#node_menu_paste', e => e.disabled), 'Paste option is still enabled');
			//delete pasted node
			await driver.contextMenu('#tree ul.dataset_model > li:nth-child(1) > ul.nodes a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:CENTER_ADDRESS_3"]');
			await driver.wait();
			assert.equal(await driver.eval('#tree ul.dataset_model > li:nth-child(1) > ul.field_model', e => e.children.length), 8, 'There are 8 field models in dataset model "ADDRESS"');
			await driver.wait();
			await driver.click('#node_menu_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#tree ul.dataset_model > li:nth-child(1) > ul.field_model', e => e.children.length), 7, 'There are 7 field models in dataset model "ADDRESS" after one has been deleted');
		});
	});*/

	await bundle.describe('clone paste', async feature => {
		await feature.it('clones a node properly', async () => {
			const study = StudyHandler.GetStudy();
			const original_node = study.getDatasetModel('CHILD');
			const original_node_child = original_node.getFieldModel('CHILD_NAME');
			//clone node
			assert.hidden(await driver.get('#node_menu', {hidden: true}), 'Node menu is hidden');
			await driver.contextMenu('#tree ul.dataset_model > li:nth-child(4) a[href="#node=Study:TEST|DatasetModel:CHILD"]');
			await driver.wait();
			assert.visible(await driver.get('#node_menu', {hidden: true}), 'Node menu is displayed after a right click on a node');
			assert.equal(await driver.eval('#tree ul.dataset_model', e => e.children.length), 20, 'There are 20 dataset models');
			await driver.click('#node_menu_clone');
			assert.equal(await driver.eval('#tree ul.dataset_model', e => e.children.length), 21, 'There are 21 dataset models after one has been cloned');
			assert.hidden(await driver.get('#node_menu', {hidden: true}), 'Node menu is hidden');
			//check cloned node in model
			const cloned_node = study.getDatasetModel('COPY_CHILD');
			assert.notEqual(original_node, cloned_node, 'Cloned node is not the same than original node');
			assert.equal(cloned_node.id, 'COPY_CHILD', 'Cloned node id is "COPY_CHILD"');
			assert.equal(cloned_node.id, `COPY_${original_node.id}`, 'Cloned node id is the id of original node prefixed by "COPY_"');
			assert.equal(cloned_node.getLocalizedShortname(selected_language), 'Child', 'Cloned node shortname is "Child"');
			assert.equal(cloned_node.getLocalizedShortname(selected_language), original_node.getLocalizedShortname(selected_language), 'Cloned node shortname is the same than original node shortname');
			//check cloned node in ui
			await driver.click('#tree ul.dataset_model > li:nth-child(5) a[href="#node=Study:TEST|DatasetModel:COPY_CHILD"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#dataset_model_id'), 'COPY_CHILD', 'Cloned node id is "COPY_CHILD"');
			assert.equal(await driver.getValueShadow('#dataset_model_shortname', 'input'), 'Child', 'Cloned node shortname is "Child"');
			//check children of cloned node in model
			const cloned_node_child = cloned_node.getFieldModel('CHILD_NAME');
			assert.notEqual(original_node_child, cloned_node_child, 'Cloned node child is not the same than original node child');
			assert.equal(cloned_node_child.id, 'CHILD_NAME', 'Cloned node id is "CHILD_NAME"');
			assert.equal(cloned_node_child.id, original_node_child.id, 'Cloned node child id is the same than original node child id');
			assert.equal(cloned_node_child.getLocalizedShortname(selected_language), 'Name', 'Cloned node child shortname is "Name"');
			assert.equal(cloned_node_child.getLocalizedShortname(selected_language), original_node_child.getLocalizedShortname(selected_language), 'Cloned node child shortname is the same than original node child shortname');
			//check cloned node in ui
			await driver.click('#tree ul.dataset_model > li:nth-child(5) > ul.field_model a[href="#node=Study:TEST|DatasetModel:COPY_CHILD|FieldModel:CHILD_NAME"]');
			await driver.wait();
			assert.equal(await driver.getValue('#field_model_id'), 'CHILD_NAME', 'Cloned node child id is "CHILD_NAME"');
			assert.equal(await driver.getValueShadow('#field_model_shortname', 'input'), 'Name', 'Cloned node child shortname is "Name"');
			//modify node
			await driver.click('#tree ul.dataset_model > li:nth-child(5) a[href="#node=Study:TEST|DatasetModel:COPY_CHILD"]');
			await driver.wait();
			await driver.type(await driver.get('#dataset_model_id'), 'ADOPTED_CHILD');
			await driver.type(await driver.getShadow('#dataset_model_shortname', 'input'), 'Adopted child');
			await driver.submit('#edit_dataset_model_form');
			//check modifications in model
			assert.equal(cloned_node.id, 'ADOPTED_CHILD', 'Cloned node id is now "ADOPTED_CHILD"');
			assert.equal(cloned_node.getLocalizedShortname(selected_language), 'Adopted child', 'Cloned node shortname is now "Adopted child"');
			assert.equal(original_node.getLocalizedShortname(selected_language), 'Child', 'Original node shortname has not been changed');
			//delete cloned node
			await driver.contextMenu('#tree ul.dataset_model > li:nth-child(3) a[href="#node=Study:TEST|DatasetModel:ADOPTED_CHILD"]');
			await driver.wait();
			assert.equal(await driver.eval('#tree ul.dataset_model', e => e.children.length), 21, 'There are 21 dataset models');
			await driver.click('#node_menu_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#tree ul.dataset_model', e => e.children.length), 20, 'There are 20 dataset models');
		});
	});

	await bundle.describe('backups', async feature => {
		await feature.it('backups the configuration properly', async () => {
			let study = StudyHandler.GetStudy();
			//check initial ui state
			await driver.click('#tree ul.study > li a[href="#node=Study:TEST"]');
			await driver.wait();
			assert.equal(await driver.getValue('#study_id'), 'TEST', 'Study id is "TEST"');
			assert.equal(await driver.getValue('#study_email'), 'info@rodano.ch', 'Study email is "info@rodano.ch"');

			//check initial model state
			assert.equal(study.id, 'TEST', 'Study id is "TEST"');
			assert.equal(study.getEventModels().length, 8, 'There are 8 event models in the configuration');
			assert.equal(study.formModels.length, 20, 'There are 20 form models in the configuration');

			//select study
			await driver.click('#tree ul.study > li a[href="#node=Study:TEST"]');
			await driver.wait();

			//save configuration
			await driver.click('#menubar > li > ul > li:nth-child(4) > button');
			await driver.type('#config_save input[name="description"]', 'First save');
			await driver.submit('#config_save > form');
			//save configuration takes some time
			await driver.wait(500);
			const date = new Date();
			//save operation should take less than a second, but can take less time than the waiting time
			await driver.click('#menubar > li > ul > li:nth-child(5) > button');
			await driver.wait();
			const last_save = Date.parseToFullDisplay(await driver.eval('#config_load_list > li:last-child > time', e => e.textContent));
			assert.ok(Date.getDifferenceInSeconds(date, last_save) < 1, 'Backups contains date of last save');
			await driver.click('#config_load_close');

			//do some modifications
			//modify study
			await driver.type('#study_id', 'TEST_BIS');
			await driver.type('#study_email', 'info@rodano.ch');
			await driver.type(await driver.getShadow('#study_shortname', 'input'), 'Test bis');
			await driver.type(await driver.getShadow('#study_longname', 'input'), 'Test bis');
			await driver.submit('#edit_study_form');
			//check modifications in ui and model
			study = StudyHandler.GetStudy();
			assert.equal(study.id, 'TEST_BIS', 'Study id is "TEST_BIS"');
			assert.equal(await driver.get('#tree a.selected'), await driver.get('#tree ul.study > li a[href="#node=Study:TEST_BIS"]'), 'Study is the selected element');
			assert.equal(await driver.eval('#tree a.selected', e => e.textContent), 'Test bis', 'Tree has been updated with new study longname');

			//delete form model
			//await driver.click(await driver.eval('#tree a[href="#node=Study:TEST_BIS&entity=FormModel"]', e => e.previousElementSibling));
			assert.equal(await driver.eval('#tree ul.form_model', e => e.childNodes.length), 20, 'There are 20 form models in the tree');
			await driver.contextMenu('#tree ul.form_model > li:nth-child(11) a[href="#node=Study:TEST_BIS|FormModel:RELAPSES"]');
			await driver.wait();
			await driver.click('#node_menu_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			//check modifications in ui and model
			assert.equal(await driver.eval('#tree ul.form_model', e => e.childNodes.length), 19, 'There are 19 form models in the tree after 1 form model has been deleted');
			assert.equal(study.formModels.length, 19, 'There are 19 form models in configuration');

			//create event model
			//await driver.click(await driver.eval('#tree a[href="#node=Study:TEST_BIS|ScopeModel:PATIENT&entity=EventModel"]', e => e.previousElementSibling));
			await driver.click('#tree ul.scope_model > li:has(a[href="#node=Study:TEST_BIS|ScopeModel:PATIENT"]) img[title="Add event model"]');
			await driver.type('#event_model_id', 'UNSCHEDULED');
			await driver.type(await driver.getShadow('#event_model_shortname', 'input'), 'Unscheduled visit');
			await driver.submit('#edit_event_model_form');
			//check modifications in ui and model
			assert.equal(await driver.eval('#tree ul.scope_model > li:has(a[href="#node=Study:TEST_BIS|ScopeModel:PATIENT"]) ul.event_model', e => e.childNodes.length), 9, 'There are 9 event models in the tree after 1 event model has been created');
			assert.equal(study.getEventModels().length, 9, 'There are 9 event models in configuration');

			//go to a validator
			//await driver.click(await driver.get('#tree ul.validator > li:nth-child(12) a[href="#node=Study:TEST|Validator:REQUIRED"]'));

			//reload configuration
			await driver.click('#menubar > li > ul > li:nth-child(5) > button');
			await driver.wait(500);
			await driver.click('#config_load_list > li:last-child');
			await driver.wait();
			await driver.click('#tree_collapse_all');
			//check model has not been altered
			study = StudyHandler.GetStudy();
			assert.equal(study.datasetModels[0].fieldModels[0].datasetModel, study.datasetModels[0], 'Relation has been preserved between a dataset model and one of its field models for a field model in the original configuration');
			const scope_model = study.getScopeModel('PATIENT');
			assert.equal(scope_model.eventModels[0].scopeModel, scope_model, 'Relation has been preserved between scope model and one of its event model');
			assert.equal(scope_model.eventModels.first().id, 'BASELINE', 'First event model id is still "BASELINE"');
			assert.equal(scope_model.eventModels.last().id, 'SLEEP', 'Last event model id is still "SLEEP"');

			//check model has been restored
			assert.equal(study.id, 'TEST', 'Study id has been restored to "TEST"');
			assert.equal(study.getEventModels().length, 8, 'There are 8 event models in configuration');
			assert.equal(study.formModels.length, 20, 'There are 20 form models in configuration');

			//check selection has been kept
			//assert.equal(await driver.get('#tree a.selected'), await driver.get('#tree ul.validator > li a[href="#node=Study:TEST|Validator:REQUIRED"]'), 'Selection has been restored a reset based on url and is study');

			//checked ui has been restored
			assert.equal(await driver.eval('#tree ul.study > li a[href="#node=Study:TEST"]', e => e.textContent), 'Test study for Rodano', 'Study id has been restored');
			await driver.click('#tree ul.study > li a[href="#node=Study:TEST"]');
			await driver.wait();
			assert.equal(await driver.getValue('#study_id'), 'TEST', 'Study id is "TEST"');
			assert.equal(await driver.getValue('#study_email'), 'info@rodano.ch', 'Study email is "info@rodano.ch"');

			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=FormModel"]', e => e.previousElementSibling));
			assert.equal(await driver.eval('#tree ul.form_model', e => e.childNodes.length), 20, 'There are now 20 form models');
			await driver.click('#tree ul.form_model > li:nth-child(11) a[href="#node=Study:TEST|FormModel:RELAPSES"]');
			await driver.wait();
			assert.equal(await driver.getValue('#form_model_id'), 'RELAPSES', 'Ninth form model id is "RELAPSES"');
			assert.equal(await driver.getValueShadow('#form_model_shortname', 'input'), 'Relapses', 'Ninth form model shortname is "Relapses"');

			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST|ScopeModel:PATIENT&entity=EventModel"]', e => e.previousElementSibling));
			assert.equal(await driver.eval('#tree ul.scope_model > li:has(a[href="#node=Study:TEST|ScopeModel:PATIENT"]) ul.event_model', e => e.childNodes.length), 8, 'There are still 8 event models');
			await driver.click('#tree ul.scope_model > li:has(a[href="#node=Study:TEST|ScopeModel:PATIENT"]) ul.event_model > li:nth-child(8) a[href="#node=Study:TEST|ScopeModel:PATIENT|EventModel:TELEPHONE_VISIT"]');
			await driver.wait();
			assert.equal(await driver.getValue('#event_model_id'), 'TELEPHONE_VISIT', 'Fifth event model id is "TELEPHONE_VISIT"');
			assert.equal(await driver.getValueShadow('#event_model_shortname', 'input'), 'Telephone visit', 'Fifth event model shortname is "Telephone visit"');
		});

		await feature.it('removes stored backups', async () => {
			//reset history
			await driver.click('#menubar > li > ul > li:nth-child(5) > button');
			await driver.click('#config_load_reset');
			//let time for backups to be deleted
			await driver.wait(1000);
			assert.equal(await driver.eval('#config_load_list', e => e.childNodes.length), 0 ,'All backups have been deleted after a reset');
			await driver.click('#config_load_close');
		});
	});

	//TODO split this
	await bundle.describe('forms', async feature => {
		const study = StudyHandler.GetStudy();
		await feature.it('edits a study', async () => {
			//check and change study
			await driver.click('#tree ul.study > li a[href="#node=Study:TEST"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#study_id'), 'TEST', 'Study id is "TEST"');
			assert.equal(await driver.getValue('#study_email'), 'info@rodano.ch', 'Study email is "info@rodano.ch"');
			await driver.type('#study_id', 'TEST_BIS');
			await driver.type(await driver.getShadow('#study_shortname', 'input'), 'Test bis');
			await driver.type(await driver.getShadow('#study_longname', 'input'), 'Test bis');
			await driver.type('#study_smtp_login', 'login');
			await driver.type('#study_smtp_password', 'password');
			await driver.submit('#edit_study_form');
			assert.equal(await driver.getValue('#study_smtp_login'), 'login', 'SMTP login is "login"');
			assert.equal(await driver.getValue('#study_smtp_password'), 'password', 'SMTP password is "password"');
			assert.equal(study.id, 'TEST_BIS', 'Study id is "TEST_BIS"');
			assert.equal(await driver.get('#tree a.selected'), await driver.get('#tree ul.study > li a[href="#node=Study:TEST_BIS"]'), 'Study is the selected element');
			assert.equal(await driver.eval('#tree a.selected', e => e.textContent), 'Test bis', 'Tree has been updated with new study longname');
			//revert modifications
			await driver.type('#study_id', 'TEST');
			await driver.type(await driver.getShadow('#study_shortname', 'input'), 'Test');
			await driver.type(await driver.getShadow('#study_longname', 'input'), 'Test');
			await driver.submit('#edit_study_form');
		});

		await feature.it('edits scope models', async () => {
			//create scope model
			await driver.click('#tree img[title="Add scope model"]');
			//let time for form to load
			await driver.wait();
			//TODO find why this test fails
			//assert.equal(await driver.eval('#tree a.selected', e => e.textContent), '', 'New scope model has no id yet so tree displays an empty string');
			//fill scope model form
			await driver.type('#scope_model_id', 'CONTINENT');
			await driver.type(await driver.getShadow('#scope_model_shortname', 'input'), 'Continent');
			await driver.type(await driver.getShadow('#scope_model_shortname', 'select'), 'fr');
			await driver.type(await driver.getShadow('#scope_model_shortname', 'input'), 'Continent');
			await driver.type('#scope_model_expected_number', 4);
			await driver.type('#scope_model_max_number', 5);
			await driver.doubleClick(await driver.getShadow('#scope_model_parent_ids', 'div > ul > li:nth-child(5)'));
			await driver.type('#scope_model_default_parent_id', 'STUDY');
			await driver.type('#scope_model_format', '${parent}-${siblingsNumber:2}');
			await driver.submit('#edit_scope_model_form');
			//TODO find why this test fails
			//assert.equal(await driver.eval('#tree a.selected', e => e.textContent), 'Continent', 'Tree has been updated and display scope model shortname');
			assert.equal(await driver.eval('#tree ul.scope_model > li:nth-child(3) a[href="#node=Study:TEST|ScopeModel:CONTINENT"]', e => e.textContent), 'Continent', 'Nodes in tree have been sorted according to entity comparator so the new scope model appears is second position');

			//move scope model inside an other one
			await driver.click('#tree ul.nodes.scope_model > li:nth-child(4) a[href="#node=Study:TEST|ScopeModel:COUNTRY"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#scope_model_default_parent_id'), 'STUDY', 'Scope model form has been updated: default parent id is "STUDY"');
			await driver.type('#scope_model_default_parent_id', 'CONTINENT');
			await driver.submit('#edit_scope_model_form');
		});

		await feature.it('edits event models', async () => {
			//create event model
			//await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=EventModel"]', e => e.previousElementSibling));
			await driver.click('#tree ul.scope_model > li:has(a[href="#node=Study:TEST|ScopeModel:PATIENT"]) img[title="Add event model"]');
			//let time for form to load
			await driver.wait();
			//TODO find why this test fails
			//assert.equal(await driver.eval('#tree a.selected', e => e.textContent), '', 'New event group has no id yet therefore tree element displays an empty string');
			await driver.submit('#edit_event_model_form');
			//TODO find why this test fails
			//assert.equal(await driver.eval('#tree a.selected', e => e.textContent), '', 'Event group id has not been modified therefore tree element still displays an empty string too');
			await driver.type('#event_model_id', 'PREGNANCY_VISIT');
			await driver.type(await driver.getShadow('#event_model_shortname', 'input'), 'Pregnancy visit');
			await driver.type(await driver.getShadow('#event_model_shortname', 'select'), 'fr');
			await driver.type(await driver.getShadow('#event_model_shortname', 'input'), 'Visite lors d\'une grossesse');
			await driver.type('#event_model_max_occurrence', 1);
			await driver.submit('#edit_event_model_form');
		});

		await feature.it('edits languages', async () => {
			//check static languages
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=Language"]', e => e.previousElementSibling));
			await driver.click('#tree ul.language > li a[href="#node=Study:TEST|Language:en"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getStyle('#edit_language', 'display'), 'block', 'Language form is visible');
			assert.ok(await driver.eval('#language_id', e => e.hasAttribute('disabled')), 'Language id is disabled because language is a static node');
			assert.equal(await driver.getValue('#language_id'), 'en', 'Language id is "en"');

			//create language
			await driver.click('#tree img[title="Add language"]');
			await driver.type('#language_id', 'de');
			await driver.type(await driver.getShadow('#language_shortname', 'input'), 'German');
			await driver.type(await driver.getShadow('#language_shortname', 'select'), 'fr');
			await driver.type(await driver.getShadow('#language_shortname', 'input'), 'Allemand');
			await driver.submit('#edit_language_form');
			await driver.click('#tree ul.language > li:nth-child(3) a[href="#node=Study:TEST|Language:de"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.evalShadow('#language_shortname', 'select', e => e.children.length), 2, 'There are 2 languages available for localization as German has not been activated yet');
			//activate language
			await driver.click('#tree ul.study > li a[href="#node=Study:TEST"]');
			await driver.wait();
			await driver.doubleClick(await driver.getShadow('#study_language_ids', 'div > ul > li:nth-child(1)'));
			await driver.submit('#edit_study_form');
			await driver.click('#tree ul.language > li:nth-child(3) a[href="#node=Study:TEST|Language:de"]');
			await driver.wait();
			assert.selectContains(await driver.getShadow('#language_shortname', 'select'), 'de');
			await driver.type(await driver.getShadow('#language_shortname', 'select'), 'de');
			await driver.type(await driver.getShadow('#language_shortname', 'input'), 'Deutsch');
			await driver.submit('#edit_language_form');
		});

		//translate previously created event model in this new language
		await driver.click('#tree ul.scope_model ul.event_model > li:nth-child(9) a[href="#node=Study:TEST|ScopeModel:PATIENT|EventModel:PREGNANCY_VISIT"]');
		await driver.wait();
		assert.selectContains(await driver.getShadow('#event_model_shortname', 'select'), 'de');
		await driver.type(await driver.getShadow('#event_model_shortname', 'select'), 'de');
		await driver.type(await driver.getShadow('#event_model_shortname', 'input'), 'Trächtigkeit Besuch');
		await driver.submit('#edit_event_model_form');

		//delete language
		assert.equal(await driver.eval('#tree ul.language', e => e.childNodes.length), 3, 'There are 3 languages in the tree');
		await driver.contextMenu('#tree ul.language > li:nth-child(3) a[href="#node=Study:TEST|Language:de"]');
		await driver.wait();
		assert.equal(await driver.getStyle('#node_menu', 'display'), 'block', 'Node menu is visible');
		await driver.click('#node_menu_delete');
		await driver.click('#validate_buttons > li:last-child > button');
		assert.equal(await driver.eval('#tree ul.language', e => e.childNodes.length), 2, 'There are 2 languages in the tree after 1 language has been deleted');
		assert.equal(study.languages.length, 2, 'There are 2 language in configuration');
		//deleting the language has updated the event model bound to the form currently displayed
		assert.similar(study.getScopeModel('PATIENT').getEventModel('PREGNANCY_VISIT').shortname, {en: 'Pregnancy visit', fr: 'Visite lors d\'une grossesse'}, 'Event model currently displayed has been updated');

		//check language has been deleted
		await driver.click('#tree ul.event_model > li:nth-child(1) a[href="#node=Study:TEST|ScopeModel:PATIENT|EventModel:BASELINE"]');
		await driver.wait();
		//as information of currently displayed event group is not consistent with the model, a confirmation window appears
		await driver.click('#validate_buttons > li:last-child > button');

		await driver.wait();
		assert.selectContains(await driver.getShadow('#event_model_shortname', 'select'), 'en');
		assert.selectContains(await driver.getShadow('#event_model_shortname', 'select'), 'fr');
		assert.equal(await driver.evalShadow('#event_model_shortname', 'select', e => e.children.length), 2, 'There are 2 languages available for event model shortname');

		//check all modifications have been reported in model
		assert.equal(study.scopeModels.length, 6, 'There are 6 scope models in configuration');
		assert.equal(study.scopeModels[5].id, 'CONTINENT', 'Last scope model id is "CONTINENT"');
		assert.equal(study.scopeModels[5].defaultParentId, 'STUDY', 'Default parent id for last scope model is "STUDY"');
		assert.equal(study.getEventModels().length, 9, 'There are 9 event models in configuration');
		const event_model = study.getScopeModel('PATIENT').getEventModel('PREGNANCY_VISIT');
		assert.equal(event_model.id, 'PREGNANCY_VISIT', 'Last event id is "PREGNANCY_VISIT"');
		assert.equal(event_model.shortname.fr, 'Visite lors d\'une grossesse', 'French shortname for last event model is "Visite lors d\'une grossesse"');
		assert.notOk(event_model.shortname.hasOwnProperty('de'), 'Last event model shortname is no more translated in "de" as this language no longer exists');
		assert.equal(study.languages.length, 2, 'There are 2 languages in configuration');

		//scope models, event models and form models matrices
		await driver.click('#menubar > li:nth-child(6) > ul > li:nth-child(2) > a');
		await driver.wait();
		assert.equal(await driver.eval('#event_models_form_models table td[data-scope-model-id="CENTER"][data-form-model-id="CENTER_ADDRESS"]', e => e.firstChild.style.opacity), '1', 'Matrix shows form model "CENTER_ADDRESS" is selected for scope model "Patient"');
		assert.equal(await driver.eval('#event_models_form_models table td[data-scope-model-id="CENTER"][data-form-model-id="STUDY_ENTRY"]', e => e.firstChild.style.opacity), '0.1', 'Matrix shows form model "STUDY_ENTRY" is not selected for scope model "Patient"');

		assert.equal(await driver.eval('#event_models_form_models table td[data-event-model-id="BASELINE"][data-form-model-id="STUDY_ENTRY"]', e => e.firstChild.style.opacity), '1', 'Matrix shows form model "STUDY_ENTRY" is selected for event model "BASELINE" for scope model "Patient"');
		assert.equal(await driver.eval('#event_models_form_models table td[data-event-model-id="VISIT_6"][data-form-model-id="STUDY_ENTRY"]', e => e.firstChild.style.opacity), '0.1', 'Matrix shows form model "STUDY_ENTRY" is not selected for event model "VISIT_6" for scope model "Patient"');

		//delete scope model
		assert.equal(await driver.eval('#tree ul.scope_model', e => e.childNodes.length), 6, 'There are 6 scope models in the tree');
		assert.equal(study.scopeModels.length, 6, 'There are 6 scope models in study');
		await driver.contextMenu('#tree ul.scope_model > li a[href="#node=Study:TEST|ScopeModel:CONTINENT"]');
		await driver.wait();
		await driver.click('#node_menu_delete');
		await driver.click('#validate_buttons > li:last-child > button');
		assert.equal(await driver.eval('#tree ul.scope_model', e => e.childNodes.length), 5, 'There are 5 scope models in the tree');
		assert.equal(study.scopeModels.length, 5, 'There are 5 scope models in study');

		//delete event model
		assert.equal(await driver.eval('#tree ul.scope_model > li:has(a[href="#node=Study:TEST|ScopeModel:PATIENT"]) ul.event_model', e => e.childNodes.length), 9, 'There are 9 event models in the tree');
		assert.equal(study.getEventModels().length, 9, 'There are 9 event models in study');
		await driver.contextMenu('#tree ul.scope_model > li:has(a[href="#node=Study:TEST|ScopeModel:PATIENT"]) ul.event_model > li a[href="#node=Study:TEST|ScopeModel:PATIENT|EventModel:PREGNANCY_VISIT"]');
		await driver.wait();
		await driver.click('#node_menu_delete');
		await driver.click('#validate_buttons > li:last-child > button');
		assert.equal(await driver.eval('#tree ul.scope_model > li:has(a[href="#node=Study:TEST|ScopeModel:PATIENT"]) ul.event_model', e => e.childNodes.length), 8, 'There are 8 event models in the tree');
		assert.equal(study.getEventModels().length, 8, 'There are 8 event models in study');
	});

	await bundle.describe('feature form', async feature => {
		await feature.it('edits features', async () => {
			const study = StudyHandler.GetStudy();
			//create
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=Feature"]', e => e.previousElementSibling));
			await driver.click('#tree img[title="Add feature"]');
			//let time for form to load
			await driver.wait();
			await driver.type('#feature_id', 'TEST_FEATURE');
			await driver.submit('#edit_feature_form');

			//feature profile matrix
			await driver.focus('#menubar > li:nth-child(4) > button:nth-child(1)');
			await driver.click('a[href="#matrix=profile&entity=Feature"]');
			await driver.wait();
			assert.equal(await driver.eval('#matrix > table > tbody', e => e.childNodes.length), 12, 'Matrix contains 12 lines because there are 12 features in configuration');
			assert.equal(await driver.eval('#matrix > table > tbody > tr:nth-child(11) > td', e => e.textContent), 'TEST_FEATURE', '11th line of matrix concerns feature "TEST_FEATURE"');

			//change feature shortname
			await driver.click('#tree ul.feature > li a[href="#node=Study:TEST|Feature:TEST_FEATURE"]');
			await driver.wait();
			await driver.type(await driver.getShadow('#feature_shortname', 'input'), 'Test feature');
			await driver.submit('#edit_feature_form');

			//feature profile matrix
			await driver.focus('#menubar > li:nth-child(4) > button:nth-child(1)');
			await driver.click('a[href="#matrix=profile&entity=Feature"]');
			await driver.wait();
			assert.equal(await driver.eval('#matrix > table > tbody > tr:nth-child(11) > td', e => e.textContent), 'Test feature', '11th line of matrix concerns feature "Test feature"');

			//delete
			assert.equal(await driver.eval('#tree ul.feature', e => e.childNodes.length), 12, 'There are 12 features in the tree');
			assert.equal(study.features.length, 12, 'There are 12 features in study');
			await driver.contextMenu('#tree ul.feature > li a[href="#node=Study:TEST|Feature:TEST_FEATURE"]');
			await driver.wait();
			await driver.click('#node_menu_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#tree ul.feature', e => e.childNodes.length), 11, 'There are 11 features in the tree');
			assert.equal(study.features.length, 11, 'There are 11 features in study');
		});
	});

	await bundle.describe('field model form', async feature => {
		await feature.it('edits field models', async () => {
			//check existing
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=DatasetModel"]', e => e.previousElementSibling));
			await driver.click(await driver.eval('#tree ul.dataset_model > li a[href="#node=Study:TEST|DatasetModel:ADDRESS"]', e => e.previousElementSibling));
			await driver.click('#tree ul.field_model > li:nth-child(1) a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:ADDRESS_1"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#field_model_id'), 'ADDRESS_1', 'Field model id is "ADDRESS_1"');
			//do not use driver API because it does not retrieve hidden element
			assert.visible('#field_model_max_length', 'Field model max length is visible');
			await driver.type('#field_model_type', 'SELECT');
			assert.equal(await driver.eval('#field_model_max_length', e => e.parentNode.style.display, {hidden: true}), 'none', 'Field model max length field is hidden');
			await driver.submit('#edit_field_model_form');

			//possible value
			await driver.click('a[href="#node=Study:TEST|DatasetModel:ADDRESS|FieldModel:ADDRESS_1&tab=edit_field_model_possible_values"]');
			//let time for form to load
			await driver.wait();
			await driver.click('#field_model_possible_values_add');
			await driver.click('#field_model_possible_values_add');
			assert.equal(document.querySelectorAll('#field_model_possible_values > div').length, 2, '2 possible values have been created');
			const possible_value_1 = await driver.get('#field_model_possible_values > div:nth-of-type(1)');
			await driver.type(possible_value_1.querySelector('input[data-name="id"]'), 'ADDRESS_1');
			await driver.type(possible_value_1.querySelector('app-localized-input[data-name="shortname"]').shadowRoot.querySelector('input'), 'Hospital avenue');
			const possible_value_2 = await driver.get('#field_model_possible_values > div:nth-of-type(2)');
			await driver.type(possible_value_2.querySelector('input[data-name="id"]'), 'ADDRESS_2');
			await driver.type(possible_value_2.querySelector('app-localized-input[data-name="shortname"]').shadowRoot.querySelector('input'), 'Doctor street');

			await driver.submit('#edit_field_model_form');
		});
	});

	await bundle.describe('validator form', async feature => {
		await feature.it('edits validators', async () => {
			const study = StudyHandler.GetStudy();
			//check
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=Validator"]', e => e.previousElementSibling));
			await driver.click('#tree ul.validator > li:nth-child(12) a[href="#node=Study:TEST|Validator:OLDER_THAN_18"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#validator_id'), 'OLDER_THAN_18', 'Ninth validator is is "OLDER_THAN_18"');
			assert.equal(await driver.getValueShadow('#validator_shortname', 'input'), 'Greater than 18 years', 'Ninth validator shortname is "Greater than 18 years"');
			assert.equal(await driver.getValueShadow('#validator_longname', 'input'), '', 'Ninth validator longname is empty');
			assert.equal(await driver.getValueShadow('#validator_description', 'input'), '', 'Ninth validator description is empty');
			assert.equal(await driver.getValue('#validator_workflow_id'), 'PROTOCOL_DEVIATION', 'Ninth validator workflow id is "PROTOCOL_DEVIATION"');
			assert.equal(await driver.getValueShadow('#validator_message', 'input'), 'Field must be greater than 18 years.', 'Ninth validator message is "Field must be greater than 18 years."');
			assert.equal(await driver.getStyle('#validator_constraint_add', 'display'), 'none', 'There is a constraint for this validator');
			assert.equal(await driver.getStyle('#validator_constraint_edit', 'display'), '', 'There is a constraint for this layout');
			assert.equal(await driver.getStyle('#validator_constraint_delete', 'display'), '', 'There is a constraint for this layout');

			//create
			await driver.click('#tree img[title="Add validator"]');
			await driver.wait();
			await driver.type('#validator_id', 'NOT_BEFORE_1980');
			await driver.type(await driver.getShadow('#validator_shortname', 'input'), 'Not before 1980');
			await driver.type(await driver.getShadow('#validator_message', 'input'), 'can\'t be before 1980');
			assert.selectContains(await driver.get('#validator_workflow_id'), 'CENTER_STATUS');
			assert.selectContains(await driver.get('#validator_workflow_id'), 'VISIT_REPORTING');
			assert.selectContains(await driver.get('#validator_workflow_id'), 'FORM_REPORTING');
			assert.selectContains(await driver.get('#validator_workflow_id'), 'PROTOCOL_DEVIATION');
			assert.selectContains(await driver.get('#validator_workflow_id'), 'QUERY');
			assert.selectContains(await driver.get('#validator_workflow_id'), 'SIGNATURE');

			//copy constraint
			assert.equal(await driver.getStyle('#validator_constraint_add', 'display'), '', 'There is no constraint for this validator');
			assert.equal(await driver.getStyle('#validator_constraint_edit', 'display'), 'none', 'There is no constraint for this layout');
			assert.equal(await driver.getStyle('#validator_constraint_delete', 'display'), 'none', 'There is no constraint for this layout');
			assert.selectContains(await driver.get('#validator_copy_rules_validators'), 'OLDER_THAN_18');
			assert.selectContains(await driver.get('#validator_copy_rules_validators'), 'AFTER_BIRTH');
			assert.selectContains(await driver.get('#validator_copy_rules_validators'), 'FEMALE_HAVE_FEELINGS');
			await driver.type('#validator_copy_rules_validators', 'OLDER_THAN_18');
			await driver.click('#validator_copy_rules');
			assert.equal(await driver.getStyle('#validator_constraint_add', 'display'), 'none', 'There is a constraint for this validator');
			assert.equal(await driver.getStyle('#validator_constraint_edit', 'display'), '', 'There is a constraint for this layout');
			assert.equal(await driver.getStyle('#validator_constraint_delete', 'display'), '', 'There is a constraint for this layout');
			await driver.submit('#edit_validator_form');

			//delete
			const validator_number = await driver.eval('#tree ul.validator', e => e.childNodes.length);
			assert.equal(study.validators.length, validator_number, 'There are the same number of validators in the study and in the tree');
			await driver.contextMenu('#tree ul.validator > li a[href="#node=Study:TEST|Validator:NOT_BEFORE_1980"]');
			await driver.wait();
			await driver.click('#node_menu_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#tree ul.validator', e => e.childNodes.length), validator_number - 1, 'There is one less validator in the tree');
			assert.equal(study.validators.length, validator_number - 1, 'There is one less validator in the study');
		});
	});

	await bundle.describe('form model form', async feature => {
		await feature.it('edits form models', async () => {
			//form model
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=FormModel"]', e => e.previousElementSibling));
			await driver.click('#tree ul.form_model > li:nth-child(10) a[href="#node=Study:TEST|FormModel:MS_HISTORY"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#form_model_id'), 'MS_HISTORY', 'Fifth form model has id "MS_HISTORY"');
			assert.selectContains(await driver.getShadow('#form_model_shortname', 'select'), 'en');
			assert.selectContains(await driver.getShadow('#form_model_shortname', 'select'), 'fr');
			assert.selectNotContains(await driver.getShadow('#form_model_shortname', 'select'), 'de');

			//layout
			await driver.click('a[href="#node=Study:TEST|FormModel:MS_HISTORY&tab=edit_form_model_insight"]');
			assert.equal(await driver.eval('#form_model_layouts', e => e.childNodes.length), 2, 'Form model has 2 layout');
			assert.equal(await driver.eval('#form_model_layouts > div > h3 > span', e => e.textContent), 'HISTORY', 'Form model first layout is "HISTORY"');
			assert.equal(await driver.eval('#form_model_layouts > div:nth-child(2) > h3 > span', e => e.textContent), 'DIAGNOSIS', 'Form model second layout is "DIAGNOSIS"');
			await driver.click('#form_model_layouts > div > h3 > a[title="Edit layout"]');
			//let time for form to load
			await driver.wait();
			assert.visible('#edit_layout', 'Layout form is visible');
			assert.equal(await driver.getValue('#layout_id'), 'HISTORY', 'First layout id is "HISTORY"');
			assert.selectContains(await driver.getShadow('#layout_description', 'select'), 'en');
			assert.selectContains(await driver.getShadow('#layout_description', 'select'), 'fr');
			assert.selectNotContains(await driver.getShadow('#layout_description', 'select'), 'de');
			assert.equal(await driver.getValue('#layout_type'), 'SINGLE', 'First layout type is "SINGLE"');
			await driver.click('#edit_layout_close');

			//layout needs time to close
			await driver.wait();
			assert.hidden('#edit_layout', 'Layout form is hidden');

			//lines
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody', e => e.children.length), 6, 'First layout has 6 lines');
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody > tr', e => e.children.length), 3, 'First line of first layout has 3 columns (1 sorting + 1 data + 1 delete)');

			//column
			await driver.click('#form_model_layouts > div > table > thead > tr > th > a[title="Edit column"]');
			//let time for form to load
			await driver.wait();
			assert.visible('#edit_column', 'Column form is visible');
			assert.equal(await driver.getValue('#column_css_code'), 'width: 1000px;', 'Column CSS code is "width: 1000px;"');
			await driver.type('#column_css_code', 'width: 900px;');
			await driver.submit('#edit_column_form');

			//column needs time to close
			await driver.wait();
			assert.hidden('#edit_column', 'Column form is hidden');

			//check column modifications
			assert.hidden('#edit_column', 'Column form is hidden');
			await driver.click('#form_model_layouts > div > table > thead > tr > th > a[title="Edit column"]');
			await driver.wait();
			assert.visible('#edit_column', 'Column form is visible');
			assert.equal(await driver.getValue('#column_css_code'), 'width: 900px;', 'Column CSS code is "width: 900px;"');
			await driver.click('#edit_column_close');

			//column needs time to close
			await driver.wait();
			assert.hidden('#edit_column', 'Column form is hidden');

			//add line
			await driver.click('#form_model_layouts > div > p > button');
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody', e => e.children.length), 7, 'First layout has 7 lines');
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody > tr:last-child > td:last-child > img', e => e.getAttribute('alt')), 'Delete line', 'Last column on last line contains an image to delete the line');

			//check modifications in model
			assert.equal(Router.selectedNode.layouts[0].lines.length, 7, 'First layout contains 7 lines');

			//remove line
			await driver.click('#form_model_layouts > div > table > tbody > tr:last-child > td:last-child > img');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody', e => e.children.length), 6, 'First layout has 6 lines');

			//check modifications in model
			assert.equal(Router.selectedNode.layouts[0].lines.length, 6, 'First layout contains 6 lines');

			//add column
			await driver.click('#form_model_layouts > div > p > button:last-child');
			assert.equal(await driver.eval('#form_model_layouts > div > table > thead > tr', e => e.children.length), 4, 'First line of first layout has 4 columns (1 sorting + 2 data + 1 delete');

			//check modifications in model
			assert.equal(Router.selectedNode.layouts[0].columns.length, 2, 'First layout contains 2 columns');
			assert.equal(Router.selectedNode.layouts[0].lines[0].cells.length, 2, 'First line of first layout contains 2 cells');

			//extend cell
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody> tr:nth-child(2) > td:nth-child(2)', e => e.colSpan), 1, 'Normal cell has colspan set to 1');
			//button is invisible because the mouse must be over the cell so it can appear
			await driver.click('#form_model_layouts > div > table > tbody> tr:nth-child(2) > td:nth-child(2) > div > a[title="Extend cell"]', {hidden: true});
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody > tr:nth-child(2) > td:nth-child(2)', e => e.colSpan), 2, 'Extended cell has colspan set to 2');
			await driver.click('#form_model_layouts > div > table > tbody> tr:nth-child(2) > td:nth-child(2) > div > a[title="Extend cell"]', {hidden: true});
			assert.equal(await driver.eval('#form_model_layouts > div > table > tbody > tr:nth-child(2) > td:nth-child(2)', e => e.colSpan), 2, 'Last cell cannot be extended');

			//check modifications in model
			let cell = Router.selectedNode.getCell('DATE_OF_FIRST_SYMPTOMS');
			assert.equal(cell.colspan, 2, 'Cell colspan is 2');
			assert.equal(cell.line.cells.length, 1, 'There is only 1 cell in extended cell line');

			//delete column
			await driver.click('#form_model_layouts > div > table > thead > tr:first-child > th:nth-child(3) > a[title="Delete column"]');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#form_model_layouts > div > table > thead > tr', e => e.children.length), 3, 'First line of first layout has 3 columns (1 sorting + 1 data + 1 delete');

			//check modifications in model
			assert.equal(Router.selectedNode.layouts[0].columns.length, 1, 'First layout contains 1 column');
			assert.equal(Router.selectedNode.layouts[0].lines[0].cells.length, 1, 'First line of first layout contains 1 cell');
			cell = Router.selectedNode.getCell('DATE_OF_FIRST_SYMPTOMS');
			assert.equal(cell.colspan, 1, 'Cell colspan is 1');
			assert.equal(cell.datasetModelId, 'PATIENT_DOCUMENTATION', 'Cell dataset model id is still "PATIENT_DOCUMENTATION"');
			assert.equal(cell.fieldModelId, 'DATE_OF_FIRST_SYMPTOMS', 'Cell field model id is still "DATE_OF_FIRST_SYMPTOMS"');

			//duplicate layout
			await driver.click('#form_model_layouts > div > h3 > a[title="Duplicate layout"]');
			assert.equal(await driver.eval('#form_model_layouts', e => e.childNodes.length), 3, 'Form model has 3 layouts');
			assert.equal(Router.selectedNode.layouts.length, 3, 'Form model in model has 3 layouts');
			assert.hidden('#edit_layout', 'Layout form is hidden');
			await driver.click('#form_model_layouts > div:nth-child(3) > h3 > a[title="Edit layout"]');
			await driver.wait();
			assert.visible('#edit_layout', 'Layout form is visible');
			await driver.click('#edit_layout_close');

			//layout needs time to close
			await driver.wait();
			assert.equal(await driver.getValue('#layout_id'), 'COPY_HISTORY', 'Third layout id is "COPY_HISTORY"');
			assert.hidden('#edit_column', 'Column form is hidden');
			assert.hidden('#edit_cell', 'Cell form is hidden');
			await driver.wait();
			//button is invisible because the mouse must be over the cell so it can appear
			await driver.click('#form_model_layouts > div:nth-child(3) > table > tbody > tr:nth-child(2) > td:nth-child(2) > div > a[title="Edit cell"]', {hidden: true});
			//let time for form to load
			await driver.wait();
			assert.visible('#edit_cell', 'Cell form is visible');
			assert.equal(await driver.getValue('#cell_id'), 'COPY_DATE_OF_FIRST_SYMPTOMS', 'Id of first cell in third layout is "COPY_DATE_OF_FIRST_SYMPTOMS"');
			await driver.click('#edit_cell_close');

			//cell needs time to close
			await driver.wait();
			assert.hidden('#edit_cell', 'Cell form is hidden');

			//delete layout
			await driver.click('#form_model_layouts > div:nth-child(3) > h3 > a[title="Delete layout"]');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#form_model_layouts', e => e.childNodes.length), 2, 'Form model has 2 layouts');
			assert.equal(Router.selectedNode.layouts.length, 2, 'Form model in model has 2 layouts');
			assert.equal(await driver.eval('#form_model_layouts > div > h3 > span', e => e.textContent), 'HISTORY', 'Form model first layout is "HISTORY"');
			assert.equal(await driver.eval('#form_model_layouts > div:nth-child(2) > h3 > span', e => e.textContent), 'DIAGNOSIS', 'Form model second layout is "DIAGNOSIS"');

			//cell
			const table = await driver.get('#form_model_layouts > div > table');
			//button is invisible because the mouse must be over the cell so it can appear
			table.querySelector('tr:nth-child(2) > td:nth-child(2) > div > a[title="Edit cell"]').click();
			//let time for form to load
			await driver.wait();
			assert.visible('#edit_cell', 'Cell form is visible');
			assert.equal(await driver.getValue('#cell_id'), 'DATE_OF_FIRST_SYMPTOMS', 'Id of first cell in first layout is "DATE_OF_FIRST_SYMPTOMS"');
			assert.equal(await driver.getStyle('#cell_visibility', 'display'), 'none', 'Visibility criteria section is hidden for cell containing field model which type is "DATE"');
			await driver.click('#edit_cell_close');

			//cell needs time to close
			await driver.wait();
			assert.hidden('#edit_cell', 'Cell form is hidden');
			//button is invisible because the mouse must be over the cell so it can appear
			table.querySelector('tr:nth-child(4) > td:nth-child(2) > div > a[title="Edit cell"]').click();
			await driver.wait();
			assert.equal(await driver.getValue('#cell_id'), 'HAS_THE_PATIENT_EXPERIENCED_A_SECOND_RELAPSE', 'Id of fourth cell in first layout is "HAS_THE_PATIENT_EXPERIENCED_A_SECOND_RELAPSE"');
			await driver.type(await driver.getShadow('#cell_text_before', 'textarea'), 'Relapses');

			//visibility criteria
			assert.equal(await driver.getStyle('#cell_visibility', 'display'), 'block', 'Visibility criteria section is displayed for cell containing field model which type is "SELECT"');
			await driver.click('#cell_visibility_criterion_add');
			assert.equal(await driver.eval('#cell_visibility_criteria', e => e.children.length), 3, 'A visibility criteria has been created (two visibility criteria and the template)');
			const values = await driver.get('#cell_visibility_criteria > div:nth-child(3) > select[data-name="values"]');
			assert.equal(values.children.length, 3, 'Visibility criteria has 3 possible values');
			assert.equal(values.firstElementChild.value, 'N', 'First possible value for visibility criteria is "N"');
			assert.equal(values.firstElementChild.textContent, 'No', 'First possible value label for visibility criteria is "No"');
			assert.selectContains(values, 'N', 'Possible values contains "N"');
			//do not select using the driver to be able to select multiple values
			values.querySelectorAll('option').forEach(o => o.selected = o.value === 'Y');

			const layout_targets = await driver.get('#cell_visibility_criteria > div:nth-child(3) > select[data-name="targetLayoutIds"]');
			assert.equal(layout_targets.children.length, 1, 'Visibility criteria has 1 target layout');
			assert.selectNotContains(layout_targets, 'HISTORY', 'Target does not contain current layout');
			assert.selectContains(layout_targets, 'DIAGNOSIS', 'Target contains layout "DIAGNOSIS"');
			//do not select using the driver to be able to select multiple values
			layout_targets.querySelectorAll('option').forEach(o => o.selected = o.value === 'DIAGNOSIS');

			const cell_targets = await driver.get('#cell_visibility_criteria > div:nth-child(3) > select[data-name="targetCellIds"]');
			assert.equal(cell_targets.children.length, 5, 'Visibility criteria has 5 target cells');
			assert.selectContains(cell_targets, 'DATE_OF_FIRST_SYMPTOMS', 'Target contains cell "DATE_OF_FIRST_SYMPTOMS"');
			assert.selectContains(cell_targets, 'DATE_OF_THE_SECOND_RELAPSE', 'Target contains "DATE_OF_THE_SECOND_RELAPSE"');
			assert.selectNotContains(cell_targets, 'DATE_OF_DIAGNOSIS', 'Target does not contain cell "DATE_OF_DIAGNOSIS" which is a cell from another layout');
			assert.selectNotContains(cell_targets, 'CONFIRMED_BY', 'Target does not contains cell "CONFIRMED_BY" which is a cell from another layout');
			assert.selectNotContains(cell_targets, 'HAS_THE_PATIENT_EXPERIENCED_A_SECOND_RELAPSE', 'Target does not contain the current cell');
			//do not select using the driver to be able to select multiple values
			cell_targets.querySelectorAll('option').forEach(o => o.selected = ['NUMBER_RELAPSE_FIRST_10_YEARS'].includes(o.value));
			await driver.submit('#edit_cell_form');

			//cell needs time to close
			await driver.wait();
			//check modifications in model
			cell = Router.selectedNode.getCell('HAS_THE_PATIENT_EXPERIENCED_A_SECOND_RELAPSE');
			assert.equal(cell.getLocalizedTextBefore(selected_language), 'Relapses', 'Cell text before is "Relapses"');

			assert.equal(cell.visibilityCriteria.length, 2, 'There are 2 visibility criteria for cell "HAS_THE_PATIENT_EXPERIENCED_A_SECOND_RELAPSE"');
			const visibility_criteria = cell.visibilityCriteria[1];
			assert.ok(visibility_criteria.values.includes('Y'), 'Visibility criteria values contains "Y"');
			assert.notOk(visibility_criteria.values.includes('N'), 'Visibility criteria values does not contain "N"');
			assert.ok(visibility_criteria.targetLayoutIds.includes('DIAGNOSIS'), 'Visibility criteria targets contains "DIAGNOSIS"');
			assert.ok(visibility_criteria.targetCellIds.includes('NUMBER_RELAPSE_FIRST_10_YEARS'), 'Visibility criteria targets contains "NUMBER_RELAPSE_FIRST_10_YEARS"');
			assert.notOk(visibility_criteria.targetCellIds.includes('DATE_OF_FIRST_SYMPTOMS'), 'Visibility criteria targets contains not "DATE_OF_FIRST_SYMPTOMS"');

			//button is invisible because the mouse must be over the cell so it can appear
			table.querySelector('tr:nth-child(4) > td:nth-child(2) > div > a[title="Edit cell"]').click();
			await driver.wait();
			assert.equal(await driver.getValueShadow('#cell_text_before', 'textarea'), 'Relapses', 'Cell text before is "Relapses"');
			assert.ok(await driver.eval('#cell_visibility_criteria > div:nth-child(3) > select[data-name="values"] > option[value="Y"]', e => e.selected), 'Visibility criteria value "Y" is selected');
			assert.notOk(await driver.eval('#cell_visibility_criteria > div:nth-child(3) > select[data-name="values"] > option[value="N"]', e => e.selected), 'Visibility criteria value "N" is not selected');
			assert.ok(await driver.eval('#cell_visibility_criteria > div:nth-child(3) > select[data-name="targetLayoutIds"] > option[value="DIAGNOSIS"]', e => e.selected), 'Visibility criteria target "DIAGNOSIS" is selected');
			assert.ok(await driver.eval('#cell_visibility_criteria > div:nth-child(3) > select[data-name="targetCellIds"] > option[value="NUMBER_RELAPSE_FIRST_10_YEARS"]', e => e.selected), 'Visibility criteria target "NUMBER_RELAPSE_FIRST_10_YEARS" is selected');
			assert.notOk(await driver.eval('#cell_visibility_criteria > div:nth-child(3) > select[data-name="targetCellIds"] > option[value="DATE_OF_FIRST_SYMPTOMS"]', e => e.selected), 'Visibility criteria value "DATE_OF_FIRST_SYMPTOMS" is not selected');
			assert.notOk(await driver.eval('#cell_visibility_criteria > div:nth-child(3) > select[data-name="targetCellIds"] > option[value="PROGRESSION_FROM_ONSET"]', e => e.selected), 'Visibility criteria value "PROGRESSION_FROM_ONSET" is not selected');

			//delete visibility criteria
			await driver.click('#cell_visibility_criteria > div:nth-child(3) > button');
			await driver.click('#validate_buttons > li:last-child > button');
			await driver.submit('#edit_cell_form');

			await driver.wait();
		});
	});

	await bundle.describe('payment plan form', async feature => {
		await feature.it('edits payment plans', async () => {
			const study = StudyHandler.GetStudy();
			//check existing
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=PaymentPlan"]', e => e.previousElementSibling));
			await driver.click('#tree ul.payment_plan > li a[href="#node=Study:TEST|PaymentPlan:DATA_MANAGEMENT_PAYMENT"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#payment_plan_id'), 'DATA_MANAGEMENT_PAYMENT', 'First payment plan is payment plan with id "DATA_MANAGEMENT_PAYMENT"');
			assert.equal(await driver.getValue('#payment_plan_currency'), 'CHF', 'First payment plan currency is "CHF"');
			assert.selectContains(await driver.get('#payment_plan_workflow_id'), 'VISIT_REPORTING');
			assert.selectContains(await driver.get('#payment_plan_workflow_id'), 'CENTER_STATUS');
			assert.selectContains(await driver.get('#payment_plan_workflow_id'), 'FORM_REPORTING');
			assert.selectContains(await driver.get('#payment_plan_workflow_state_id'), 'READY_TO_REVIEW');
			assert.selectContains(await driver.get('#payment_plan_workflow_state_id'), 'REVIEWED');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'INCOMPLETE');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'COMPLETE');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'LOCKED');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'UNLOCKED');
			await driver.type('#payment_plan_workflow_id', 'VISIT_REPORTING');
			assert.selectContains(await driver.get('#payment_plan_workflow_state_id'), 'EMPTY');
			assert.selectContains(await driver.get('#payment_plan_workflow_state_id'), 'INCOMPLETE');
			assert.selectContains(await driver.get('#payment_plan_workflow_state_id'), 'COMPLETE');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'READY_TO_REVIEW');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'REVIEWED');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'LOCKED');
			assert.selectNotContains(await driver.get('#payment_plan_workflow_state_id'), 'UNLOCKED');

			//create
			await driver.click('#tree img[title="Add payment plan"]');
			await driver.type('#payment_plan_id', 'SIGNATURE_PAYMENT');
			await driver.type(await driver.getShadow('#payment_plan_shortname', 'input'), 'Signature payment');
			await driver.type('#payment_plan_currency', 'EUR');
			await driver.type('#payment_plan_invoiced_scope_model_id', 'PATIENT');
			await driver.type('#payment_plan_workflow_id', 'SIGNATURE');
			await driver.type('#payment_plan_workflow_state_id', 'SIGNED');
			await driver.submit('#edit_payment_plan_form');
			assert.equal(await driver.eval('#tree ul.payment_plan', e => e.childNodes.length), 2, 'There are 2 payment plans in the tree');
			assert.equal(study.paymentPlans.length, 2, 'There are 2 payment plans in study');

			//hook payment dataset model
			assert.selectContains(await driver.get('#payment_plan_event_id'), 'BASELINE');
			assert.selectContains(await driver.get('#payment_plan_event_id'), 'VISIT_12');
			assert.selectContains(await driver.get('#payment_plan_event_id'), 'TERMINATION_VISIT');

			await driver.type('#payment_plan_event_id', 'BASELINE');
			await driver.click('#payment_plan_hook');
			assert.equal(await driver.eval('#tree ul.dataset_model', e => e.childNodes.length), 21, 'There are 21 dataset models in the tree');
			assert.equal(study.datasetModels.length, 21, 'There are 21 dataset models in study');

			//delete generated dataset model
			await driver.contextMenu('#tree ul.dataset_model > li:nth-child(16) a[href="#node=Study:TEST|DatasetModel:SIGNATURE_PAYMENT"]');
			await driver.wait();
			await driver.click('#node_menu_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#tree ul.dataset_model', e => e.childNodes.length), 20, 'There are 20 dataset models in the tree');
			assert.equal(study.datasetModels.length, 20, 'There are 20 dataset models in study');

			//delete
			await driver.contextMenu('#tree ul.payment_plan > li:nth-child(2) a[href="#node=Study:TEST|PaymentPlan:SIGNATURE_PAYMENT"]');
			await driver.wait();
			await driver.click('#node_menu_delete');
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(await driver.eval('#tree ul.payment_plan', e => e.childNodes.length), 1, 'There is 1 payment plan in the tree');
			assert.equal(study.paymentPlans.length, 1, 'There are 1 payment plan in study');
		});
	});

	await bundle.describe('menu form', async feature => {
		await feature.it('edits menus', async () => {
			//edit
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=Menu"]', e => e.previousElementSibling));
			await driver.click('#tree ul.entities > li > ul.menu > li:nth-child(2) a[href="#node=Study:TEST|Menu:CENTERS"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#menu_id'), 'CENTERS', 'Second menu id is "CENTERS"');
			assert.equal(await driver.getValue('#menu_action_page'), 'scopes', 'Menu action page is "scopes"');
			assert.equal(await driver.getValue('#menu_action_context'), '["CENTER"]', 'Menu action context is ["CENTER"]');
			await driver.submit('#edit_menu_form');
			//check that parameters have been saved
			await driver.click('#tree ul.entities > li > ul.menu > li:nth-child(11) a[href="#node=Study:TEST|Menu:USERS"]');
			await driver.wait();
			assert.equal(await driver.getValue('#menu_id'), 'USERS', 'Third menu id is "USERS"');
			await driver.click('#tree ul.entities > li > ul.menu > li:nth-child(2) a[href="#node=Study:TEST|Menu:CENTERS"]');
			await driver.wait();
			assert.equal(await driver.getValue('#menu_id'), 'CENTERS', 'Second menu id is "CENTERS"');
			assert.equal(await driver.getValue('#menu_action_page'), 'scopes', 'Second menu action page is "scopes"');
			assert.equal(await driver.getValue('#menu_action_context'), '["CENTER"]', 'Second menu action page is ["CENTER"]');
		});
	});

	await bundle.describe('rule definition property form', async feature => {
		await feature.it('edits rule definition properties', async () => {
			//edit
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=RuleDefinitionProperty"]', e => e.previousElementSibling));
			await driver.click('#tree ul.entities > li > ul.rule_definition_property > li:nth-child(1) a[href="#node=Study:TEST|RuleDefinitionProperty:CUSTOM_SCOPE_PROPERTY_1"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#rule_definition_property_id'), 'CUSTOM_SCOPE_PROPERTY_1', 'First rule definition property id is "CUSTOM_SCOPE_PROPERTY_1"');
			assert.equal(await driver.getValue('#rule_definition_property_label'), 'First custom scope property', 'First rule definition property label is "First custom scope property"');
			assert.equal(await driver.getValue('#rule_definition_property_entity'), 'SCOPE', 'First rule definition property entity is "SCOPE"');
			assert.equal(await driver.getValue('#rule_definition_property_target'), 'SCOPE', 'First rule definition property target is "SCOPE"');
			assert.equal(await driver.getValue('#rule_definition_property_type'), 'STRING', 'First rule definition property type is "STRING"');
			await driver.type('#rule_definition_property_id', 'CUSTOM_EVENT_PROPERTY_1');
			await driver.type('#rule_definition_property_label', 'First custom event property');
			await driver.type('#rule_definition_property_entity', 'EVENT');
			await driver.type('#rule_definition_property_target', 'DATASET');
			await driver.type('#rule_definition_property_type', 'NUMBER');
			await driver.submit('#edit_rule_definition_property_form');
			//check that properties have been saved
			await driver.click('#tree ul.entities > li > ul.rule_definition_action > li:nth-child(1) a[href="#node=Study:TEST|RuleDefinitionAction:CUSTOM_SCOPE_ACTION_1"]');
			await driver.wait();
			assert.equal(await driver.getValue('#rule_definition_action_id'), 'CUSTOM_SCOPE_ACTION_1', 'First rule definition action id is "CUSTOM_SCOPE_ACTION_1"');
			await driver.click('#tree ul.entities > li > ul.rule_definition_property > li:nth-child(1) a[href="#node=Study:TEST|RuleDefinitionProperty:CUSTOM_EVENT_PROPERTY_1"]');
			await driver.wait();
			assert.equal(await driver.getValue('#rule_definition_property_id'), 'CUSTOM_EVENT_PROPERTY_1', 'First rule definition property id is "CUSTOM_EVENT_PROPERTY_1"');
			assert.equal(await driver.getValue('#rule_definition_property_label'), 'First custom event property', 'First rule definition property label is "First custom event property"');
			assert.equal(await driver.getValue('#rule_definition_property_entity'), 'EVENT', 'First rule definition property entity is "EVENT"');
			assert.equal(await driver.getValue('#rule_definition_property_target'), 'DATASET', 'First rule definition property target is "DATASET"');
			assert.equal(await driver.getValue('#rule_definition_property_type'), 'NUMBER', 'First rule definition property type is "NUMBER"');
		});
	});

	await bundle.describe('rule definition action form', async feature => {
		await feature.it('edits rule definition actions', async () => {
			//edit
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=RuleDefinitionAction"]', e => e.previousElementSibling));
			await driver.click('#tree ul.entities > li > ul.rule_definition_action > li:nth-child(1) a[href="#node=Study:TEST|RuleDefinitionAction:CUSTOM_SCOPE_ACTION_1"]');
			//let time for form to load
			await driver.wait();
			assert.equal(await driver.getValue('#rule_definition_action_id'), 'CUSTOM_SCOPE_ACTION_1', 'First rule definition action id is "CUSTOM_SCOPE_ACTION_1"');
			assert.equal(await driver.getValue('#rule_definition_action_label'), 'First custom scope action', 'First rule definition action label is "First custom scope action"');
			assert.equal(await driver.getValue('#rule_definition_action_entity'), 'SCOPE', 'First rule definition property entity is "SCOPE"');
			let parameters_container = await driver.get('#rule_definition_action_parameters');
			assert.equal(parameters_container.children.length, 1, 'There is 0 parameter for selected action');
			await driver.click('#rule_definition_action_parameters_add');
			assert.equal(parameters_container.children.length, 2, 'There is 1 parameter for selected action');
			let parameter_inputs = parameters_container.children[1].querySelectorAll('input,select');
			await driver.type(parameter_inputs[0], 'EVENT');
			await driver.type(parameter_inputs[1], 'Event');
			await driver.type(parameter_inputs[3], 'EventModel');
			await driver.click('#rule_definition_action_parameters_add');
			assert.equal(parameters_container.children.length, 3, 'There are 2 parameters for selected action');
			await driver.click(parameters_container.children[2].querySelector('button[title="Delete parameter"]'));
			await driver.click('#validate_buttons > li:last-child > button');
			assert.equal(parameters_container.children.length, 2, 'There are 1 parameter for selected action');
			await driver.submit('#edit_rule_definition_action_form');
			//check that parameters have been saved
			await driver.click('#tree ul.entities > li > ul.rule_definition_action > li:nth-child(2) a[href="#node=Study:TEST|RuleDefinitionAction:CUSTOM_SCOPE_ACTION_2"]');
			await driver.wait();
			assert.equal(await driver.getValue('#rule_definition_action_id'), 'CUSTOM_SCOPE_ACTION_2', 'Second rule definition action id is "CUSTOM_SCOPE_ACTION_2"');
			await driver.click('#tree ul.entities > li > ul.rule_definition_action > li:nth-child(1) a[href="#node=Study:TEST|RuleDefinitionAction:CUSTOM_SCOPE_ACTION_1"]');
			await driver.wait();
			assert.equal(await driver.getValue('#rule_definition_action_id'), 'CUSTOM_SCOPE_ACTION_1', 'First rule definition action id is "CUSTOM_SCOPE_ACTION_1"');
			parameters_container = await driver.get('#rule_definition_action_parameters');
			assert.equal(parameters_container.children.length, 2, 'There is 1 parameter for selected action');
			parameter_inputs = parameters_container.children[1].querySelectorAll('input,select');
			assert.equal(parameter_inputs[0].value, 'EVENT', 'Action first parameter id is "EVENT"');
			assert.equal(parameter_inputs[1].value, 'Event', 'Action first parameter label is "Event"');
			assert.equal(parameter_inputs[3].value, 'EventModel', 'Action first parameter configuration entity is "Event model"');
		});
	});

	await bundle.describe('tree', async feature => {
		const study = StudyHandler.GetStudy();
		//check configuration has been loaded
		assert.equal(study.menus.length, 11, 'There are 11 menus in configuration');

		await feature.it('expands and collapses the whole tree', async () => {
			//expand and collapse tree
			await driver.click('#tree_expand_all');
			assert.ok(await driver.eval('#tree ul.nodes.form_model', e => e.classList.contains('expanded'), {hidden: true}), 'Form models are displayed');
			assert.ok(await driver.eval('#tree ul.nodes.validator', e => e.classList.contains('expanded'), {hidden: true}), 'Validators are displayed');
			assert.ok(await driver.eval('#tree ul.nodes.dataset_model', e => e.classList.contains('expanded'), {hidden: true}), 'Dataset models are displayed');
			await driver.click('#tree_collapse_all');
			assert.notOk(await driver.eval('#tree ul.nodes.form_model', e => e.classList.contains('expanded'), {hidden: true}), 'Form models are hidden');
			assert.notOk(await driver.eval('#tree ul.nodes.validator', e => e.classList.contains('expanded'), {hidden: true}), 'Validators are hidden');
			assert.notOk(await driver.eval('#tree ul.nodes.dataset_model', e => e.classList.contains('expanded'), {hidden: true}), 'Dataset models are hidden');
		});

		await feature.it('expands only one entity', async () => {
			//expand scope model
			assert.notOk(await driver.eval('#tree ul.nodes.scope_model', e => e.classList.contains('expanded'), {hidden: true}), 'Scope models are hidden');
			await driver.click(await driver.eval('#tree a[href="#node=Study:TEST&entity=ScopeModel"]', e => e.previousElementSibling));
			assert.ok(await driver.eval('#tree ul.nodes.scope_model', e => e.classList.contains('expanded'), {hidden: true}), 'Scope models are displayed');
		});
	});

	await bundle.describe('assignable matrix', async feature => {
		await feature.it('displays the assignable matrix', async () => {
			const study = StudyHandler.GetStudy();
			await driver.click('a[href="#matrix=profile&entity=Feature"]');
			await driver.wait();
			assert.equal(await driver.getStyle('#matrix', 'display'), 'block', 'Matrix section is visible');
			assert.equal(await driver.eval('#matrix', e => e.childNodes.length), 1, 'There is 1 matrix shown');
			assert.equal(await driver.eval('#matrix > table > caption', e => e.textContent), 'Features', 'First matrix is feature matrix');
			assert.equal(await driver.eval('#matrix > table > tbody', e => e.childNodes.length), 11, 'First matrix contains 11 lines because there are 11 features in configuration');
			await driver.click('img[title="Give right on REVIEW_VISIT for profile INVESTIGATOR');
			assert.ok(study.getProfile('INVESTIGATOR').grantedFeatureIds.includes('REVIEW_VISIT'), '"REVIEW_VISIT" has been added for profile "INVESTIGATOR"');

			await driver.click('img[title="Remove right on REVIEW_VISIT for profile INVESTIGATOR"]');
			assert.notOk(study.getProfile('INVESTIGATOR').grantedFeatureIds.includes('REVIEW_VISIT'), '"REVIEW_VISIT" has been removed for profile "INVESTIGATOR"');
		});
	});

	await bundle.describe('right assignable matrix', async feature => {
		await feature.it('displays the right assignable matrix', async () => {
			const study = StudyHandler.GetStudy();
			await driver.click('a[href="#matrix=profile&entity=DatasetModel"]');
			await driver.wait();

			assert.equal(await driver.getStyle('#matrix', 'display'), 'block', 'Matrix section is visible');
			assert.equal(await driver.eval('#matrix', e => e.childNodes.length), 1, 'There is 1 matrix shown');
			assert.equal(await driver.eval('#matrix > table > caption', e => e.textContent), 'Dataset models', 'First matrix is dataset models matrix');
			assert.equal(await driver.eval('#matrix > table > tbody', e => e.childNodes.length), 20, 'First matrix contains 20 lines because there are 19 dataset models in configuration');

			await driver.click('span[title="Give right READ on ADDRESS for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'READ'), 'Right "READ" on "ADDRESS" has been added for profile "PRINCIPAL_INVESTIGATOR"');
			assert.notOk(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'WRITE'), 'Only right "READ" on "ADDRESS" has been added for profile "PRINCIPAL_INVESTIGATOR"');

			await driver.click('span[title="Remove right READ on ADDRESS for profile PRINCIPAL_INVESTIGATOR"]');
			assert.notOk(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'READ'), 'Right "READ" on "ADDRESS" has been removed for profile "PRINCIPAL_INVESTIGATOR"');
			assert.notOk(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'WRITE'), 'Right "WRITE" on "ADDRESS" has not been updated for profile "PRINCIPAL_INVESTIGATOR"');

			await driver.click('span[title="Give right WRITE on ADDRESS for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'WRITE'), 'Right "WRITE" on "ADDRESS" has been added for profile "PRINCIPAL_INVESTIGATOR"');
			assert.ok(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'READ'), 'Right "READ" on "ADDRESS" has been added for profile "PRINCIPAL_INVESTIGATOR"');

			await driver.click('span[title="Remove right WRITE on ADDRESS for profile PRINCIPAL_INVESTIGATOR"]');
			assert.notOk(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'WRITE'), 'Right "WRITE" on "ADDRESS" has been removed for profile "PRINCIPAL_INVESTIGATOR"');
			assert.ok(study.getProfile('PRINCIPAL_INVESTIGATOR').isAssignedRight(Entities.DatasetModel, 'ADDRESS', 'READ'), 'Right "READ" on "ADDRESS" has not been updated for profile "PRINCIPAL_INVESTIGATOR"');
		});
	});

	await bundle.describe('attributable matrix', async feature => {
		await feature.it('displays the attributable matrix', async () => {
			await driver.click('a[href="#matrix=profile&entity=Workflow"]');
			await driver.wait();

			assert.equal(await driver.getStyle('#matrix', 'display'), 'block', 'Matrix section is visible');
			assert.equal(await driver.eval('#matrix', e => e.childNodes.length), 1, 'There is 1 matrix shown');
			assert.equal(await driver.eval('#matrix > table > caption', e => e.textContent), 'Workflows', 'First matrix is workflows matrix');
			assert.equal(await driver.eval('#matrix > table > tbody', e => e.childNodes.length), 40, 'Matrix contains 40 lines because there are 40 workflows and actions in configuration');

			//give right on attributable
			assert.ok(await driver.eval('img[title="Give right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s not possible to give right on an assignable if no right has been given on its attributable');
			assert.ok(await driver.eval('img[title="See details of VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s not possible to see right details of an assignable if no right has been given on its attributable');
			assert.ok(await driver.eval('img[title="Give right on SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/untick.png')), 'If no right has been given to an attributable, there is no check displayed');
			await driver.click('img[title="Give right on SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(await driver.eval('img[title="Remove right on SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/tick.png')), 'Giving the right on an attributable adds the associated check');
			assert.notOk(await driver.eval('img[title="Give right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s possible to give right on an assignable if the right has been given on its attributable');
			assert.notOk(await driver.eval('img[title="See details of VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s possible to see right details of an assignable if the right has been given on its attributable');

			//check no right has been given on assignable
			assert.ok(await driver.eval('img[title="Give right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/untick.png')), 'If no right has been given to an attributable, there is no check displayed');
			await driver.click('img[title="See details of VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(await driver.eval('#profile_right_matrix_matrix > ul', e => e.children.every(c => c.firstElementChild.src.includes('/untick.png'))), 'If no right has been given to an assignable, no check is displayed in details panel');
			await driver.click('#profile_right_matrix_matrix > h2 > img');

			//give right on assignable
			await driver.click('img[title="Give right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(await driver.eval('img[title="Remove right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/tick.png')), 'If right has been given to an attributable, there is a check displayed');

			//check that every profile is checked in details panel
			await driver.click('img[title="See details of VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(await driver.eval('#profile_right_matrix_matrix > ul', e => e.children.every(c => c.firstElementChild.src.includes('/tick.png'))), 'If no right has been given to an assignable, no check is displayed in details panel');
			await driver.click('#profile_right_matrix_matrix > h2 > img');

			//give partial right on an assignable
			await driver.click('img[title="See details of UNVERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			await driver.click('#profile_right_matrix_matrix > ul > li:nth-child(10) > img');
			assert.ok(await driver.eval('#profile_right_matrix_matrix > ul > li:nth-child(10) > img', e => e.src.includes('/tick.png')), 'Giving custom right to an assignable displays the appropriate check');
			await driver.click('#profile_right_matrix_matrix > h2 > img');
			assert.ok(await driver.eval('img[title="Remove right on UNVERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"', e => e.src.includes('/check_error.png')), 'Giving custom right to an assignable displays the appropriate icon');

			//reload the matrix to check if modifications are persistent
			await driver.click('#tree ul.study > li:first-child a[href="#node=Study:TEST"]');
			await driver.wait();
			await driver.click('a[href="#matrix=profile&entity=Workflow"]');
			await driver.wait();
			//check that rights have been preserved on attributable
			assert.ok(await driver.eval('img[title="Remove right on SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/tick.png')), 'If right has been given to an attributable, there is a check displayed');
			//check that rights have been preserved on assignable
			assert.ok(await driver.eval('img[title="Remove right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/tick.png')), 'If right has been given to an attributable, there is a check displayed');
			await driver.click('img[title="See details of VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(await driver.eval('#profile_right_matrix_matrix > ul', e => e.children.every(c => c.firstElementChild.src.includes('/tick.png'))), 'If no right has been given to an assignable, no check is displayed in details panel');
			await driver.click('#profile_right_matrix_matrix > h2 > img');
			//check that partial rights have been preserved on assignable
			assert.ok(await driver.eval('img[title="Remove right on UNVERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/check_error.png')), 'Giving custom right to an assignable displays the appropriate icon');
			await driver.click('img[title="See details of UNVERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(await driver.eval('#profile_right_matrix_matrix > ul > li:nth-child(9) > img', e => e.src.includes('/untick.png')), 'Giving custom right to an assignable displays the appropriate check');
			assert.ok(await driver.eval('#profile_right_matrix_matrix > ul > li:nth-child(10) > img', e => e.src.includes('/tick.png')), 'Giving custom right to an assignable displays the appropriate check');
			assert.ok(await driver.eval('#profile_right_matrix_matrix > ul > li:nth-child(11) > img', e => e.src.includes('/untick.png')), 'Giving custom right to an assignable displays the appropriate check');
			await driver.click('#profile_right_matrix_matrix > h2 > img');

			//remove right on attributable
			assert.ok(await driver.eval('img[title="Remove right on SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/tick.png')), 'If right has been given to an attributable, there is a check displayed');
			assert.notOk(await driver.eval('img[title="Remove right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s possible to give right on an assignable if the right has been given on its attributable');
			assert.notOk(await driver.eval('img[title="See details of VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s possible to see right details of an assignable if the right has been given on its attributable');
			await driver.click('img[title="Remove right on SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]');
			assert.ok(await driver.eval('img[title="Give right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s not possible to give right on an assignable if no right has been given on its attributable');
			assert.ok(await driver.eval('img[title="See details of VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.hasAttribute('disabled')), 'It\'s not possible to see right details of an assignable if no right has been given on its attributable');
			assert.ok(await driver.eval('img[title="Give right on SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/untick.png')), 'Removing the right on an attributable removes the associated check');

			//removing right on an attributable also removes right on all attributable assignables
			assert.ok(await driver.eval('img[title="Give right on VERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/untick.png')), 'Removing right on an attributable also removes right on all attributable assignables');
			assert.ok(await driver.eval('img[title="Give right on UNVERIFY of SOURCE_DATA_VERIFICATION for profile PRINCIPAL_INVESTIGATOR"]', e => e.src.includes('/untick.png')), 'Removing right on an attributable also removes right on all attributable assignables');
		});
	});

	bundle.end();
}
